--------------------------------------------------
Chemin: ./eslint.config.js
Taille: 877 octets
Date de modification: 2025-06-23 18:28:33.311994500 +0100
Contenu:
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'

export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...reactHooks.configs.recommended.rules,
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]
--------------------------------------------------
Chemin: ./index.html
Taille: 307 octets
Date de modification: 2025-06-23 18:28:33.312988800 +0100
Contenu:
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Accident</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
--------------------------------------------------
Chemin: ./package.json
Taille: 945 octets
Date de modification: 2025-06-23 18:28:33.320007600 +0100
Contenu:
{
  "name": "traffic-visualization",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "axios": "^1.8.4",
    "fuzzball": "^2.2.2",
    "leaflet": "^1.9.4",
    "leaflet.heat": "^0.2.0",
    "prop-types": "^15.8.1",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-icons": "^5.5.0",
    "react-leaflet": "^5.0.0",
    "react-router-dom": "^7.4.1",
    "react-select": "^5.10.1",
    "recharts": "^2.15.1"
  },
  "devDependencies": {
    "@eslint/js": "^9.21.0",
    "@types/react": "^19.0.10",
    "@types/react-dom": "^19.0.4",
    "@vitejs/plugin-react-swc": "^3.8.0",
    "eslint": "^9.21.0",
    "eslint-plugin-react-hooks": "^5.1.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "globals": "^15.15.0",
    "vite": "^6.2.0"
  }
}
--------------------------------------------------
Chemin: ./src/App.css
Taille: 1119 octets
Date de modification: 2025-06-23 18:28:33.325002900 +0100
Contenu:
#root {
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}
/* src/App.css */
.App {
  text-align: center;
  font-family: Arial, sans-serif;
}

button {
  margin: 0 5px;
  padding: 10px 20px;
  font-size: 16px;
  cursor: pointer;
  background-color: #f0f0f0;
  border: 1px solid #ccc;
  border-radius: 5px;
}

button:hover {
  background-color: #ddd;
}

h1 {
  color: #333;
  margin-bottom: 20px;
}

h3 {
  color: #555;
  margin-bottom: 10px;
}

.leaflet-container {
  border: 1px solid #ccc;
  border-radius: 5px;
}

--------------------------------------------------
Chemin: ./src/App.jsx
Taille: 657 octets
Date de modification: 2025-06-23 18:28:33.326026700 +0100
Contenu:
import React from 'react';
import { Routes, Route } from 'react-router-dom';
import TrafficMap from './components/Traffic';
import AccidentPrediction from './components/AccidentPrediction';
import Path from './components/Path';
import './App.css';

function App() {
  console.log('App rendu, URL actuelle :', window.location.pathname);
  return (
    <Routes>
      <Route path="/" element={<TrafficMap />} />
      <Route path="/predictions" element={<AccidentPrediction />} />
      <Route path="/path" element={<Path />} />
      <Route path="*" element={<div>404 - Page non trouvée</div>} />
    </Routes>
  );
}

export default App;--------------------------------------------------
Chemin: ./src/components/AccidentPrediction.jsx
Taille: 5184 octets
Date de modification: 2025-06-23 18:28:33.331533000 +0100
Contenu:
import React, { useState, useEffect } from 'react';
import axios from 'axios';
import StreetSelector from './StreetSelector';
import PredictionChart from './Chart';
import PredictionTable from './AccidentTable';
import LoadingSpinner from './LoadingSpinner';
import ErrorMessage from './ErrorMessage';

const AccidentPrediction = () => {
  const [streets, setStreets] = useState([]);
  const [selectedStreet, setSelectedStreet] = useState('');
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchStreets = async () => {
      setLoading(true);
      try {
        const response = await axios.get('http://localhost:5000/api/streets');
        setStreets(response.data);
        setSelectedStreet(response.data[0] || '');
      } catch (err) {
        setError('Erreur lors du chargement des rues: ' + err.message);
      } finally {
        setLoading(false);
      }
    };
    fetchStreets();
  }, []);

  useEffect(() => {
    if (!selectedStreet) return;

    const fetchPredictions = async () => {
      setLoading(true);
      try {
        const url = `http://localhost:5000/api/predictions/${encodeURIComponent(selectedStreet)}`;
        const response = await axios.get(url);
        // Vérifier que la réponse contient les données attendues
        if (!response.data?.train || !response.data?.test || !response.data?.future) {
          throw new Error('Données de prédiction incomplètes ou mal formées');
        }
        setData(response.data);
        setError(null);
      } catch (err) {
        setError(err.response?.data?.error || 'Erreur réseau: ' + err.message);
        setData(null);
      } finally {
        setLoading(false);
      }
    };
    fetchPredictions();
  }, [selectedStreet]);

  // Agréger les données pour réduire le bruit (moyenne sur 7 jours)
  const aggregateData = (dates, values, label) => {
    const aggregated = [];
    const interval = 7; // Moyenne sur 7 jours
    if (!Array.isArray(dates) || !Array.isArray(values)) {
      return aggregated; // Retourner un tableau vide si les données sont invalides
    }
    for (let i = 0; i < dates.length; i += interval) {
      const sliceDates = dates.slice(i, i + interval);
      const sliceValues = values.slice(i, i + interval);
      const avgValue = sliceValues.reduce((sum, val) => sum + (val || 0), 0) / sliceValues.length;
      aggregated.push({
        date: sliceDates[0],
        [label]: avgValue,
      });
    }
    return aggregated;
  };

  // Préparer les données pour le graphique avec des vérifications
  const chartData = data?.train && data?.test && data?.future
    ? [
        ...(data.train.dates && data.train.real
          ? aggregateData(data.train.dates, data.train.real, 'Train').map((d, i) => ({
              ...d,
              'Pred Train': aggregateData(data.train.dates, data.train.predictions, 'Pred Train')[i]?.['Pred Train'] || 0,
            }))
          : []),
        ...(data.test.dates && data.test.real
          ? aggregateData(data.test.dates, data.test.real, 'Test').map((d, i) => ({
              ...d,
              'Pred Test': aggregateData(data.test.dates, data.test.predictions, 'Pred Test')[i]?.['Pred Test'] || 0,
            }))
          : []),
        ...(data.future
          ? data.future.map((item) => ({
              date: item.date,
              'Pred Future': item.predicted_accidents || 0,
            }))
          : []),
      ]
    : [];

  return (
    <div
      style={{
        maxWidth: '1200px',
        margin: '0 auto',
        padding: '20px',
        fontFamily: "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif",
        backgroundColor: '#f5f5f5',
        borderRadius: '10px',
        boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)',
      }}
    >
      <h1
        style={{
          textAlign: 'center',
          color: '#333',
          marginBottom: '30px',
          fontSize: '2.5rem',
        }}
      >
        Prédictions des accidents
      </h1>

      {loading && streets.length === 0 ? (
        <LoadingSpinner message="Chargement des rues..." />
      ) : error && streets.length === 0 ? (
        <ErrorMessage message={error} />
      ) : (
        <StreetSelector
          streets={streets}
          selectedStreet={selectedStreet}
          onStreetChange={setSelectedStreet}
        />
      )}

      {loading && streets.length > 0 && (
        <LoadingSpinner message="Chargement des prédictions..." />
      )}
      {error && streets.length > 0 && <ErrorMessage message={error} />}
      {data && !loading && chartData.length > 0 ? (
        <div>
          <PredictionChart chartData={chartData} />
          <PredictionTable futureData={data.future || []} selectedStreet={selectedStreet} />
        </div>
      ) : (
        !loading && streets.length > 0 && <ErrorMessage message="Aucune donnée disponible pour cette rue." />
      )}
    </div>
  );
};

export default AccidentPrediction;--------------------------------------------------
Chemin: ./src/components/AccidentTable.jsx
Taille: 2460 octets
Date de modification: 2025-06-23 18:28:33.332540000 +0100
Contenu:
import React from 'react';

const PredictionTable = ({ futureData, selectedStreet }) => {
  return (
    <div>
      <h2
        style={{
          textAlign: 'center',
          color: '#333',
          marginBottom: '20px',
          fontSize: '1.8rem',
        }}
      >
        Prédictions futures pour {selectedStreet}
      </h2>
      <div
        style={{
          backgroundColor: '#fff',
          padding: '20px',
          borderRadius: '10px',
          boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
        }}
      >
        <table
          style={{
            width: '100%',
            borderCollapse: 'collapse',
            textAlign: 'center',
          }}
        >
          <thead>
            <tr style={{ backgroundColor: '#e9ecef', color: '#333' }}>
              <th style={{ padding: '12px', borderBottom: '2px solid #dee2e6' }}>Date</th>
              <th style={{ padding: '12px', borderBottom: '2px solid #dee2e6' }}>
                Prédictions d'accidents
              </th>
              <th style={{ padding: '12px', borderBottom: '2px solid #dee2e6' }}>Rue</th>
            </tr>
          </thead>
          <tbody>
            {futureData.map((item, index) => (
              <tr
                key={index}
                style={{
                  backgroundColor: index % 2 === 0 ? '#f8f9fa' : '#fff',
                  transition: 'background-color 0.3s',
                }}
                onMouseEnter={(e) => (e.currentTarget.style.backgroundColor = '#e9ecef')}
                onMouseLeave={(e) =>
                  (e.currentTarget.style.backgroundColor = index % 2 === 0 ? '#f8f9fa' : '#fff')
                }
              >
                <td style={{ padding: '12px', borderBottom: '1px solid #dee2e6' }}>
                  {new Date(item.date).toLocaleDateString('fr-FR', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                  })}
                </td>
                <td style={{ padding: '12px', borderBottom: '1px solid #dee2e6' }}>
                  {item.predicted_accidents.toFixed(6)}
                </td>
                <td style={{ padding: '12px', borderBottom: '1px solid #dee2e6' }}>{item.street}</td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
};

export default PredictionTable;--------------------------------------------------
Chemin: ./src/components/api.jsx
Taille: 613 octets
Date de modification: 2025-06-23 18:28:33.346533600 +0100
Contenu:
import axios from 'axios';

export const fetchStreets = async () => {
  try {
    const response = await axios.get('http://localhost:5000/api/streets');
    return response.data;
  } catch (error) {
    throw new Error('Erreur lors du chargement des rues: ' + error.message);
  }
};

export const fetchPredictions = async (street) => {
  try {
    const response = await axios.get(`http://localhost:5000/api/predictions/${encodeURIComponent(street)}`);
    return response.data;
  } catch (error) {
    throw new Error(error.response?.data?.error || 'Erreur réseau: ' + error.message);
  }
};
--------------------------------------------------
Chemin: ./src/components/Chart.jsx
Taille: 1934 octets
Date de modification: 2025-06-23 18:28:33.334536700 +0100
Contenu:
import React from 'react';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend } from 'recharts';

const PredictionChart = ({ chartData }) => {
  return (
    <div
      style={{
        backgroundColor: '#fff',
        padding: '20px',
        borderRadius: '10px',
        boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
        marginBottom: '30px',
      }}
    >
      <LineChart
        width={1100}
        height={400}
        data={chartData}
        margin={{ top: 20, right: 30, left: 20, bottom: 20 }}
      >
        <CartesianGrid strokeDasharray="3 3" stroke="#ddd" />
        <XAxis
          dataKey="date"
          tickFormatter={(date) => new Date(date).toLocaleDateString('fr-FR')}
          interval={Math.floor(chartData.length / 10)}
          angle={-45}
          textAnchor="end"
          height={60}
        />
        <YAxis />
        <Tooltip
          formatter={(value) => value.toFixed(2)}
          labelFormatter={(label) => new Date(label).toLocaleDateString('fr-FR')}
        />
        <Legend verticalAlign="top" height={36} />
        <Line type="monotone" dataKey="Train" stroke="#1e90ff" name="Données entraînement" dot={false} />
        <Line
          type="monotone"
          dataKey="Pred Train"
          stroke="#00ced1"
          strokeDasharray="5 5"
          name="Prédictions entraînement"
          dot={false}
        />
        <Line type="monotone" dataKey="Test" stroke="#32cd32" name="Données test" dot={false} />
        <Line
          type="monotone"
          dataKey="Pred Test"
          stroke="#ffa500"
          strokeDasharray="5 5"
          name="Prédictions test"
          dot={false}
        />
        <Line type="monotone" dataKey="Pred Future" stroke="#ff4500" name="Prédictions futures" dot={false} />
      </LineChart>
    </div>
  );
};

export default PredictionChart;--------------------------------------------------
Chemin: ./src/components/ErrorMessage.jsx
Taille: 191 octets
Date de modification: 2025-06-23 18:28:33.335534500 +0100
Contenu:
import React from 'react';

const ErrorMessage = ({ message }) => {
  return (
    <p style={{ textAlign: 'center', color: 'red' }}>{message}</p>
  );
};

export default ErrorMessage;--------------------------------------------------
Chemin: ./src/components/LoadingSpinner.jsx
Taille: 196 octets
Date de modification: 2025-06-23 18:28:33.336535600 +0100
Contenu:
import React from 'react';

const LoadingSpinner = ({ message }) => {
  return (
    <p style={{ textAlign: 'center', color: '#666' }}>{message}</p>
  );
};

export default LoadingSpinner;--------------------------------------------------
Chemin: ./src/components/NavigationButton.jsx
Taille: 480 octets
Date de modification: 2025-06-23 18:28:33.337534800 +0100
Contenu:
import React from "react";
import { useNavigate } from "react-router-dom";

const NavigationButton = ({ to, label }) => {
  const navigate = useNavigate();

  return (
    <button
      onClick={() => navigate(to)}
      style={{
        margin: "0 5px",
        padding: "10px",
        backgroundColor: "#fff",
        border: "1px solid #ccc",
        cursor: "pointer",
      }}
    >
      {label}
    </button>
  );
};

export default NavigationButton;--------------------------------------------------
Chemin: ./src/components/Path.jsx
Taille: 21406 octets
Date de modification: 2025-06-24 16:28:09.586383600 +0100
Contenu:
import React, { useState, useEffect } from 'react';
import { MapContainer, TileLayer, Marker, Popup, Polyline, useMap } from 'react-leaflet';
import 'leaflet/dist/leaflet.css';
import axios from 'axios';
import L from 'leaflet';
import { ratio } from 'fuzzball';
import { FaTimes } from 'react-icons/fa';

// Correction des icônes Leaflet
delete L.Icon.Default.prototype._getIconUrl;
L.Icon.Default.mergeOptions({
  iconRetinaUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon-2x.png',
  iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
  shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
});

function MapUpdater({ bounds }) {
  const map = useMap();
  useEffect(() => {
    if (bounds) {
      map.fitBounds(bounds);
    }
  }, [bounds, map]);
  return null;
}

const Path=()=> {
  const userPosition = [40.7501, -73.9749];
  const [destination, setDestination] = useState(null);
  const [streetName, setStreetName] = useState('');
  const [route, setRoute] = useState([]);
  const [riskAlerts, setRiskAlerts] = useState([]);
  const [showAlternativePrompt, setShowAlternativePrompt] = useState(false);
  const [alternativeRoute, setAlternativeRoute] = useState(null);
  const [riskZones, setRiskZones] = useState([]);
  const [loading, setLoading] = useState(true);
  const [checkingRisks, setCheckingRisks] = useState(false);
  const [alternativeMessage, setAlternativeMessage] = useState('');
  const [showMainRoute, setShowMainRoute] = useState(false);
  const [evaluatedRoutes, setEvaluatedRoutes] = useState([]);
  const [selectedRouteIndex, setSelectedRouteIndex] = useState(null);

  const streetNameCache = new Map();

  useEffect(() => {
    const fetchRiskZones = async () => {
      try {
        const startTime = Date.now();
        const response = await axios.get('http://localhost:3003/api/accidents/zones');
        console.log('Données des zones à risque récupérées :', response.data);
        console.log(`Temps de récupération des zones à risque : ${Date.now() - startTime} ms`);
        setRiskZones(response.data);
        setLoading(false);
      } catch (error) {
        console.error("Erreur lors de la récupération des zones à risque :", error);
        setLoading(false);
      }
    };
    fetchRiskZones();
  }, []);

  const handleGeocode = async () => {
    try {
      setRiskAlerts([]);
      setRoute([]);
      setAlternativeRoute(null);
      setShowAlternativePrompt(false);
      setAlternativeMessage('');
      setEvaluatedRoutes([]);
      setSelectedRouteIndex(null);

      const response = await axios.get(
        `https://nominatim.openstreetmap.org/search?format=json&q=${streetName},+New+York,+NY`
      );
      if (response.data.length > 0) {
        const { lat, lon } = response.data[0];
        const newDestination = [parseFloat(lat), parseFloat(lon)];
        setDestination(newDestination);
        fetchAndOptimizeRoute(newDestination);
      } else {
        alert("Adresse non trouvée à New York. Vérifiez le nom de la rue.");
      }
    } catch (error) {
      console.error("Erreur lors du géocodage :", error);
    }
  };

  const fetchRoute = async (destinationCoords, avoidPoints = [], alternatives = false) => {
    try {
      let url;
      if (avoidPoints.length > 0) {
        const validAvoidPoints = avoidPoints.filter(point => 
          Array.isArray(point) && point.length === 2 && !isNaN(point[0]) && !isNaN(point[1])
        );
        if (validAvoidPoints.length === 0) {
          console.warn("Aucun point valide à éviter. Génération d'un itinéraire sans points à éviter.");
          url = `http://router.project-osrm.org/route/v1/driving/${userPosition[1]},${userPosition[0]};${destinationCoords[1]},${destinationCoords[0]}?overview=full&geometries=geojson&alternatives=${alternatives}`;
        } else {
          const waypoints = validAvoidPoints
            .map(point => `${point[1]},${point[0]}`)
            .join(';');
          url = `http://router.project-osrm.org/route/v1/driving/${userPosition[1]},${userPosition[0]};${waypoints};${destinationCoords[1]},${destinationCoords[0]}?overview=full&geometries=geojson&alternatives=${alternatives}`;
        }
      } else {
        url = `http://router.project-osrm.org/route/v1/driving/${userPosition[1]},${userPosition[0]};${destinationCoords[1]},${destinationCoords[0]}?overview=full&geometries=geojson&alternatives=${alternatives}`;
      }

      console.log('URL de la requête OSRM:', url);
      const response = await axios.get(url);

      if (response.data.routes && response.data.routes.length > 0) {
        const routes = response.data.routes.map(route => ({
          coordinates: route.geometry.coordinates.map(coord => [coord[1], coord[0]]),
          distance: route.distance,
          duration: route.duration,
        }));
        return routes;
      } else {
        console.warn("Aucune route trouvée par OSRM:", response.data);
        return [];
      }
    } catch (error) {
      console.error("Erreur lors de la récupération du chemin :", error);
      return [];
    }
  };

  const getStreetNamesFromRoute = async (routeCoordinates) => {
    const streetNames = new Set();
    const samplePoints = routeCoordinates.filter((_, index) => index % 10 === 0).slice(0, 5);

    console.log('Points échantillonnés pour le géocodage inversé :', samplePoints);

    const promises = samplePoints.map(async (coord, index) => {
      const cacheKey = `${coord[0]},${coord[1]}`;
      if (streetNameCache.has(cacheKey)) {
        console.log(`Utilisation du cache pour ${cacheKey}: ${streetNameCache.get(cacheKey)}`);
        return streetNameCache.get(cacheKey);
      }

      try {
        await new Promise(resolve => setTimeout(resolve, index * 200));
        const response = await axios.get(
          `https://nominatim.openstreetmap.org/reverse?format=json&lat=${coord[0]}&lon=${coord[1]}&addressdetails=1`
        );
        console.log(`Réponse de Nominatim pour ${coord} :`, response.data);
        const address = response.data.address;
        if (address && address.road) {
          const streetName = address.road.toUpperCase();
          streetNameCache.set(cacheKey, streetName);
          return streetName;
        }
        return null;
      } catch (error) {
        console.error(`Erreur lors du géocodage inversé pour ${coord}:`, error);
        return null;
      }
    });

    const results = await Promise.all(promises);
    results.forEach(street => {
      if (street) streetNames.add(street);
    });

    console.log('Noms des rues trouvés sur l\'itinéraire :', Array.from(streetNames));
    return Array.from(streetNames);
  };

  const normalizeStreetName = (street) => {
    let normalized = street.toUpperCase();
    normalized = normalized
      .replace(/\b1ST\b/, "FIRST")
      .replace(/\b2ND\b/, "SECOND")
      .replace(/\b3RD\b/, "THIRD")
      .replace(/\b([4-9])TH\b/, "$1TH")
      .replace(/\bFIRST\b/, "1ST")
      .replace(/\bSECOND\b/, "2ND")
      .replace(/\bTHIRD\b/, "3RD");
    return normalized.trim();
  };

  const evaluateRouteRisk = async (routeCoordinates) => {
    const streetNames = await getStreetNamesFromRoute(routeCoordinates);
    const alerts = [];
    const riskyStreets = new Set();
    let highRiskCount = 0;

    console.log('Street names from route:', streetNames);
    console.log('Risk zones data:', riskZones);

    streetNames.forEach(street => {
      const normalizedStreet = normalizeStreetName(street);
      const matchingZone = riskZones.find(zone => {
        const normalizedZoneName = normalizeStreetName(zone.route_name);
        const similarity = ratio(normalizedStreet, normalizedZoneName);
        console.log(
          `Comparing "${normalizedStreet}" with "${normalizedZoneName}" - Similarity: ${similarity}`
        );
        return similarity > 75;
      });

      if (matchingZone) {
        const riskIndex = matchingZone.normalizedRiskIndex;
        console.log(`Matched street: ${street}, RiskIndex: ${riskIndex}`);
        if (riskIndex > 0) {
          alerts.push({
            message: `⚠️ Zone à risque détectée : ${street} (Indice de risque : ${riskIndex.toFixed(2)})`,
            riskIndex: riskIndex,
          });
          riskyStreets.add(street);
          if (riskIndex >= 1) highRiskCount++;
        }
      } else {
        console.log(`No match found for street: ${street}`);
      }
    });

    const riskScore = alerts.reduce((sum, alert) => sum + alert.riskIndex, 0);
    console.log('Generated alerts:', alerts);
    return { alerts, riskyStreets: Array.from(riskyStreets), riskScore, highRiskCount };
  };

  const fetchAndOptimizeRoute = async (destinationCoords) => {
    setCheckingRisks(true);
    setShowMainRoute(false);

    const routes = await fetchRoute(destinationCoords, [], true);
    if (routes.length === 0) {
      setAlternativeMessage("Impossible de trouver un itinéraire.");
      setCheckingRisks(false);
      return;
    }

    const evaluatedRoutes = [];
    for (const route of routes) {
      const { alerts, riskyStreets, riskScore, highRiskCount } = await evaluateRouteRisk(route.coordinates);
      console.log(`Evaluated route alerts:`, alerts);
      evaluatedRoutes.push({
        coordinates: route.coordinates,
        alerts,
        riskyStreets,
        riskScore,
        highRiskCount,
        distance: route.distance,
        duration: route.duration,
      });
    }

    setEvaluatedRoutes(evaluatedRoutes);

    // Sélectionner l'itinéraire avec le score de risque le plus bas par défaut
    const safestRouteIndex = evaluatedRoutes.reduce((minIndex, route, index, arr) =>
      route.riskScore < arr[minIndex].riskScore ? index : minIndex, 0);

    console.log('Safest route index:', safestRouteIndex);
    console.log('Safest route riskScore:', evaluatedRoutes[safestRouteIndex].riskScore);

    let selectedRoute = evaluatedRoutes[safestRouteIndex];
    setSelectedRouteIndex(safestRouteIndex);

    console.log('Selected route alerts:', selectedRoute.alerts);
    setRiskAlerts(() => selectedRoute.alerts);

    setTimeout(() => {
      setRoute(selectedRoute.coordinates);
      setShowMainRoute(true);
    }, 2000);

    // Vérifier s'il y a des itinéraires alternatifs
    const alternativeRoutes = evaluatedRoutes.filter(route => route !== selectedRoute);
    if (alternativeRoutes.length > 0) {
      alternativeRoutes.sort((a, b) => a.riskScore - b.riskScore);
      let secondSafestRoute = alternativeRoutes[0]; // Prendre le plus sûr parmi les alternatifs

      console.log('Selected route riskScore:', selectedRoute.riskScore);
      console.log('Second safest route riskScore:', secondSafestRoute.riskScore);

      // Si l'itinéraire alternatif est plus sûr, échanger via l'état
      if (secondSafestRoute.riskScore < selectedRoute.riskScore) {
        console.warn('Warning: secondSafestRoute has a lower riskScore than selectedRoute. Swapping routes.');
        const temp = selectedRoute;
        selectedRoute = secondSafestRoute;
        secondSafestRoute = temp;
        setSelectedRouteIndex(evaluatedRoutes.findIndex(route => route === selectedRoute));
        setRiskAlerts(() => selectedRoute.alerts);
        setRoute(selectedRoute.coordinates);
      }

      setAlternativeRoute(secondSafestRoute.coordinates);
      setAlternativeMessage(
        `Itinéraire principal : ${secondSafestRoute.riskScore.toFixed(2)} score de risque, ${secondSafestRoute.highRiskCount} zone(s) très risquée(s).
        \nItinéraire alternatif : ${selectedRoute.riskScore.toFixed(2)} score de risque, ${selectedRoute.highRiskCount} zone(s) très risquée(s).`
      );
      console.log('Setting showAlternativePrompt to true');
      setShowAlternativePrompt(true);
    } else {
      setAlternativeMessage("Aucun itinéraire alternatif trouvé.");
      console.log('Setting showAlternativePrompt to false: No alternative routes');
      setShowAlternativePrompt(false);
    }

    setCheckingRisks(false);
  };

  // Fonction pour adopter l'itinéraire alternatif comme principal
  const handleAlternativeRoute = () => {
    // Vérification si au moins deux itinéraires existent
    if (evaluatedRoutes.length > 1) {
      // Mise à jour de l'index sélectionné
      setSelectedRouteIndex(1);
      // Affichage de l'itinéraire alternatif en bleu
      setRoute(evaluatedRoutes[1].coordinates);
      // Mise à jour des alertes avec celles de l'itinéraire alternatif
      setRiskAlerts(evaluatedRoutes[1].alerts);
      // Activation de l'affichage de l'itinéraire principal
      setShowMainRoute(true);
      // Masquage de l'ancien itinéraire principal
      setAlternativeRoute(null);
      // Message confirmant l'adoption de l'itinéraire alternatif
      setAlternativeMessage("Itinéraire alternatif adopté comme nouveau principal.");
      // Masquage de l'invite
      setShowAlternativePrompt(false);
    }
  };
  const handleDeleteAlert = (indexToDelete) => {
    setRiskAlerts(prevAlerts => prevAlerts.filter((_, index) => index !== indexToDelete));
    if (riskAlerts.length === 1) {
      setShowAlternativePrompt(false);
    }
  };

  const getRiskColor = (riskIndex) => {
    if (riskIndex >= 1) return '#ff4444'; // Rouge
    if (riskIndex >= 0.5) return '#ffbb33'; // Orange
    return '#ffeb3b'; // Jaune
  };

  // Fonction pour gérer le clic sur "Itinéraire 1"
  const handleSelectRoute1 = () => {
    if (evaluatedRoutes.length > 0) {
      setSelectedRouteIndex(0);
      setRoute(evaluatedRoutes[0].coordinates);
      setRiskAlerts(evaluatedRoutes[0].alerts);
      setShowMainRoute(true);
    }
  };

  // Fonction pour gérer le clic sur "Itinéraire 2"
  const handleSelectRoute2 = () => {
    if (evaluatedRoutes.length > 1) {
      setSelectedRouteIndex(1);
      setRoute(evaluatedRoutes[1].coordinates);
      setRiskAlerts(evaluatedRoutes[1].alerts);
      setShowMainRoute(true);
      setAlternativeRoute(null);
    }
  };

  const bounds = destination ? [userPosition, destination] : null;

  if (loading) {
    return <div style={styles.container}>Chargement des données...</div>;
  }

  console.log('État riskAlerts avant le rendu :', riskAlerts);

  return (
    <div style={styles.container}>
      <div style={styles.searchBar}>
        <input
          type="text"
          value={streetName}
          onChange={(e) => setStreetName(e.target.value)}
          placeholder="Entrez un nom de rue à New York"
          style={styles.input}
        />
        <button onClick={handleGeocode} style={styles.button}>
          Rechercher
        </button>
      </div>

      {/* Ajout des boutons pour choisir l'itinéraire */}
      {evaluatedRoutes.length > 0 && (
        <div style={styles.routeButtonsContainer}>
          <button
            onClick={handleSelectRoute1}
            style={{
              ...styles.routeButton,
              backgroundColor: selectedRouteIndex === 0 ? '#0078FF' : '#6c757d',
            }}
          >
            Itinéraire 1
          </button>
          {evaluatedRoutes.length > 1 && (
            <button
              onClick={handleSelectRoute2}
              style={{
                ...styles.routeButton,
                backgroundColor: selectedRouteIndex === 1 ? '#0078FF' : '#6c757d',
              }}
            >
              Itinéraire 2
            </button>
          )}
        </div>
      )}

      {checkingRisks && (
        <div style={styles.loadingContainer}>
          Vérification des zones à risque...
        </div>
      )}

      <div style={styles.contentWrapper}>
        <MapContainer center={userPosition} zoom={13} style={styles.map}>
          <TileLayer
            url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
            attribution='© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
          />
          <Marker position={userPosition}>
            <Popup>Position de l'utilisateur</Popup>
          </Marker>
          {destination && (
            <Marker position={destination}>
              <Popup>Point d'arrivée : {streetName}</Popup>
            </Marker>
          )}
          {showMainRoute && route.length > 0 && (
            <Polyline 
              positions={route} 
              color="#0078FF" 
              weight={4} 
              opacity={0.8} 
            />
          )}
          {alternativeRoute && (
            <Polyline 
              positions={alternativeRoute} 
              color="#28a745" 
              weight={4} 
              opacity={0.8} 
            />
          )}
          {bounds && <MapUpdater bounds={bounds} />}
        </MapContainer>

        {riskAlerts.length > 0 && (
          <div style={styles.alertContainer}>
            {riskAlerts.map((alert, index) => (
              <div key={index} style={{
                ...styles.alert,
                backgroundColor: getRiskColor(alert.riskIndex),
                display: 'flex', alignItems: 'center', justifyContent: 'space-between'
              }}>
                <div style={{ flexGrow: 1 }}>
                  <strong>{alert.message}</strong>
                  <progress value={alert.riskIndex} max="1"></progress>
                </div>
                <button onClick={() => handleDeleteAlert(index)} style={styles.deleteButton}>
                  <FaTimes size={16} />
                </button>
              </div>
            ))}
          </div>
        )}
      </div>

      {showAlternativePrompt && (
        <div style={styles.promptContainer}>
          <p>  Des zones à risque ont été détectées. Voulez-vous un itinéraire plus sûr ?</p>
          {alternativeMessage && <p style={{ color: '#ff4444' }}>{alternativeMessage}</p>}
          <button onClick={handleAlternativeRoute} style={styles.promptButton}>
            Oui, adopter l'itinéraire alternatif
          </button>
          <button
            onClick={() => setShowAlternativePrompt(false)}
            style={{ ...styles.promptButton, backgroundColor: '#6c757d' }}
          >
            Non, continuer
          </button>
        </div>
      )}
    </div>
  );
}

const styles = {
  container: {
    height: '700px',
    width: '1500px',
    flexDirection: 'column',
    backgroundColor: '#f0f2f5',
    fontFamily: 'Arial, sans-serif',
  },
  searchBar: {
    padding: '12px',
    backgroundColor: '#ffffff',
    boxShadow: '0 2px 5px rgba(0, 0, 0, 0.1)',
    display: 'flex',
    gap: '10px',
    zIndex: 1000,
  },
  routeButtonsContainer: {
    padding: '10px 15px',
    backgroundColor: '#ffffff',
    display: 'flex',
    gap: '10px',
    zIndex: 1000,
  },
  routeButton: {
    padding: '8px 15px',
    fontSize: '14px',
    color: '#ffffff',
    border: 'none',
    borderRadius: '5px',
    cursor: 'pointer',
    transition: 'background-color 0.3s',
  },
  contentWrapper: {
    display: 'flex',
    flexDirection: 'row',
    flex: 1,
    position: 'relative',
  },
  input: {
    flex: 1,
    padding: '10px 15px',
    fontSize: '16px',
    borderRadius: '8px',
    border: '1px solid #dcdcdc',
    outline: 'none',
    transition: 'border-color 0.3s',
  },
  button: {
    padding: '10px 20px',
    fontSize: '16px',
    backgroundColor: '#0078FF',
    color: '#ffffff',
    border: 'none',
    borderRadius: '8px',
    cursor: 'pointer',
    transition: 'background-color 0.3s',
  },
  map: {
    height: '600px',
    width: '1200px',
  },
  loadingContainer: {
    position: 'absolute',
    top: '80px',
    left: '20px',
    zIndex: 1000,
    backgroundColor: '#ffffff',
    padding: '10px',
    borderRadius: '5px',
    boxShadow: '0 2px 5px rgba(0, 0, 0, 0.2)',
  },
  alertContainer: {
    position: 'absolute',
    top: '0px',
    right: '20px',
    zIndex: 1000,
    maxWidth: '300px',
  },
  alert: {
    color: '#ffffff',
    padding: '10px',
    marginBottom: '10px',
    borderRadius: '5px',
    boxShadow: '0 2px 5px rgba(0, 0, 0, 0.2)',
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  deleteButton: {
    backgroundColor: 'transparent',
    border: 'none',
    color: '#ffffff',
    cursor: 'pointer',
    padding: '5px',
  },
  promptContainer: {
    position: 'absolute',
    bottom: '20px',
    left: '20px',
    backgroundColor: '#ffffff',
    padding: '10px',
    borderRadius: '8px',
    boxShadow: '0 2px 5px rgba(0, 0, 0, 0.2)',
    zIndex: 1000,
    maxWidth: '500px',
    width: '100%',
    boxSizing: 'border-box',
  },
  promptButton: {
    padding: '6px 12px',
    margin: '5px 2px',
    backgroundColor: '#28a745',
    color: '#ffffff',
    border: 'none',
    borderRadius: '5px',
    cursor: 'pointer',
    fontSize: '14px',
  },
};

export default Path;--------------------------------------------------
Chemin: ./src/components/StreetSelector.jsx
Taille: 1258 octets
Date de modification: 2025-06-23 18:28:33.341531300 +0100
Contenu:
import React from 'react';

const StreetSelector = ({ streets, selectedStreet, onStreetChange }) => {
  return (
    <div style={{ marginBottom: '30px', display: 'flex', justifyContent: 'center' }}>
      <div style={{ width: '400px' }}>
        <label
          htmlFor="street-select"
          style={{
            display: 'block',
            marginBottom: '10px',
            fontWeight: 'bold',
            color: '#555',
          }}
        >
          Sélectionner une rue :
        </label>
        <select
          id="street-select"
          value={selectedStreet}
          onChange={(e) => onStreetChange(e.target.value)}
          style={{
            width: '100%',
            padding: '10px',
            fontSize: '16px',
            borderRadius: '5px',
            border: '1px solid #ccc',
            boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
            backgroundColor: '#fff',
          }}
        >
          <option value="">-- Choisir une rue --</option>
          {streets.map((street) => (
            <option key={street} value={street}>
              {street}
            </option>
          ))}
        </select>
      </div>
    </div>
  );
};

export default StreetSelector;--------------------------------------------------
Chemin: ./src/components/Traffic.jsx
Taille: 8102 octets
Date de modification: 2025-06-23 18:28:33.342532900 +0100
Contenu:
import React, { useState, useEffect } from "react";
import { MapContainer, TileLayer, Circle, Popup, Marker, useMap } from "react-leaflet";
import "leaflet/dist/leaflet.css";
import L from "leaflet";
import "leaflet.heat";
import { useNavigate } from "react-router-dom"; // Importez useNavigate
const API_BASE_URL = "http://localhost:3010/accidents";


// Composant personnalisé pour la heatmap
const HeatmapLayerCustom = ({ points }) => {
  const map = useMap();

  useEffect(() => {
    if (!points || !Array.isArray(points) || points.length === 0) return;

    // Filtrer les points invalides et formater pour leaflet.heat
    const validPoints = points
      .filter((point) => 
        typeof point.lat === "number" && 
        !isNaN(point.lat) && 
        typeof point.lng === "number" && 
        !isNaN(point.lng) && 
        typeof point.intensity === "number" && 
        !isNaN(point.intensity)
      )
      .map((point) => [point.lat, point.lng, point.intensity]);

    if (validPoints.length === 0) return;

    const heatLayer = L.heatLayer(validPoints, {
      radius: 20,
      max: 100,
      minOpacity: 0.3,
      gradient: { 0.4: "green", 0.65: "yellow", 1: "red" },
    }).addTo(map);

    return () => {
      map.removeLayer(heatLayer);
    };
  }, [map, points]);

  return null;
};

const TrafficMap = () => {
  const navigate = useNavigate();
  console.log('TrafficMap rendu, URL actuelle :', window.location.pathname);

  const handleNavigation = (url) => {
    console.log('Navigation vers :', url);
    navigate(url);
  };
  const [view, setView] = useState("TrafficAccidents");
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    setLoading(true);
    setError(null);
    let endpoint = "";

    switch (view) {
      case "heatmap":
        endpoint = "/crash-per-period";
        break;
      case "dangerous-zones":
        endpoint = "/top-dangerous-zones";
        break;
      case "TrafficAccidents":
        endpoint = "/crash-per-period";
        break;
      default:
        setLoading(false);
        return;
    }

    fetch(`${API_BASE_URL}${endpoint}`)
      .then((res) => {
        if (!res.ok) throw new Error(`Erreur HTTP: ${res.status}`);
        return res.json();
      })
      .then((json) => {
        setData(Array.isArray(json) ? json : []); // Garantir un tableau
        setLoading(false);
      })
      .catch((err) => {
        console.error("Erreur lors de la récupération des données", err);
        setError(err.message);
        setLoading(false);
      });
  }, [view]);

  const calculateCenter = (data) => {
    if (!Array.isArray(data) || data.length === 0) return [40.7128, -74.006];
    const validData = data.filter(
      (item) => item.latitude !== undefined && item.longitude !== undefined
    );
    if (validData.length === 0) return [40.7128, -74.006];
    const sumLat = validData.reduce((sum, item) => sum + parseFloat(item.latitude), 0);
    const sumLng = validData.reduce((sum, item) => sum + parseFloat(item.longitude), 0);
    return [sumLat / validData.length, sumLng / validData.length];
  };

  const getRiskColor = (risk) => {
    if (risk >= 75) return "red";
    else if (risk >= 50) return "orange";
    else if (risk >= 25) return "yellow";
    else return "green";
  };

  const getCircleRadius = (risk) => {
    if (!risk || risk === 0) return 0;
    else if (risk <= 100 && risk >80) return 400;
    else if (risk <= 80 && risk >60) return 200;
    else if (risk <= 60 && risk >50) return 120;
    else if (risk <= 50 && risk >40) return 90;
    else if (risk <= 40 && risk >30) return 80;
    else if (risk <= 30 && risk >20) return 70;
    else if (risk <= 20 && risk >10) return 60;
    else return 30;
  };

  const renderMapContent = () => {
    if (loading || error || !Array.isArray(data) || data.length === 0) return null;

    switch (view) {
      case "heatmap":
        const heatmapPoints = data.map((zone) => ({
          lat: parseFloat(zone.latitude),
          lng: parseFloat(zone.longitude),
          intensity: parseFloat( zone.freq || 0),
        }));
        return <HeatmapLayerCustom points={heatmapPoints} />;

      case "dangerous-zones":
        return data.map((zone, index) => (
          <Marker
            key={index}
            position={[parseFloat(zone.latitude), parseFloat(zone.longitude)]}
          >
            <Popup>
              <b>{zone.on_street_name}</b>
              <br />
              Accidents: {zone.totalAccidents}
              <br />
              Blessés: {zone.totalInjured}
              <br />
              Tués: {zone.totalKilled}
              <br />
              Risque: {(zone.riskPercentage)}%
            </Popup>
          </Marker>
        ));

      
      case "TrafficAccidents":
        return data.map((accident, index) => (
          <Circle
            key={index}
            center={[parseFloat(accident.latitude), parseFloat(accident.longitude)]}
            radius={getCircleRadius(accident.indice_de_risque)}
            color={getRiskColor(accident.indice_de_risque)}
            fillOpacity={0.5}
          >
            <Popup>
              <b>{accident.on_street_name}</b>
              <br />
              Accidents: {accident.totalAccidents}
              <br />
              Blessés: {accident.totalInjured}
              <br />
              Tués: {accident.totalKilled }
              <br />
              Risque: {accident.indice_de_risque}%
            </Popup>
          </Circle>
        ));

      default:
        return null;
    }
  };

  const center = calculateCenter(data);

  return (
    <div style={{ textAlign: "center", padding: "20px" }}>
      <div style={{ marginBottom: "20px" }}>
        {["heatmap", "dangerous-zones", "TrafficAccidents"].map((type) => (
          <React.Fragment key={type}>
            <button
              onClick={() => setView(type)}
              style={{
                margin: "0 5px",
                padding: "10px",
                backgroundColor: view === type ? "#ddd" : "#fff",
                border: "1px solid #ccc",
                cursor: "pointer",
              }}
            >
              {type === "heatmap"
                ? "Carte de chaleur"
                : type === "dangerous-zones"
                ? "Zones dangereuses"
                : "TrafficAccidents"}
            </button>
           
          </React.Fragment>

        ))}
       <button
          onClick={() => handleNavigation('predictions')} // Changer '/predictions' en 'predictions'
          style={{
            margin: "0 5px",
            padding: "10px",
            backgroundColor: "#fff",
            border: "1px solid #ccc",
            cursor: "pointer",
          }}
        >
          Voir les prédictions
        </button>
        <button
  onClick={() => handleNavigation('path')} // Changer '/path' en 'path'
  style={{
    margin: "0 5px",
    padding: "10px",
    backgroundColor: "#fff",
    border: "1px solid #ccc",
    cursor: "pointer",
  }}
>
  Voir le chemin
</button>

      </div>

      {loading && <p>Chargement des données...</p>}
      {error && <p style={{ color: "red" }}>Erreur: {error}</p>}
      {!loading && !error && (!Array.isArray(data) || data.length === 0) && (
        <p>Aucune donnée disponible.</p>
      )}

     
      <MapContainer
        center={center}
        zoom={12}
        style={{ height: "600px", width: "1500px" }}
      >
        <TileLayer
          url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
          attribution='<a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        />
        {renderMapContent()}
      </MapContainer>
    </div>
  );
};

export default TrafficMap;--------------------------------------------------
Chemin: ./src/components/ViewButtons.jsx
Taille: 820 octets
Date de modification: 2025-06-23 18:28:33.343535500 +0100
Contenu:
import React from "react";

const ViewButtons = ({ view, setView }) => {
  const views = [
    { id: "heatmap", label: "Carte de chaleur" },
    { id: "dangerous-zones", label: "Zones dangereuses" },
    { id: "TrafficAccidents", label: "TrafficAccidents" },
  ];

  return (
    <>
      {views.map((type) => (
        <React.Fragment key={type.id}>
          <button
            onClick={() => setView(type.id)}
            style={{
              margin: "0 5px",
              padding: "10px",
              backgroundColor: view === type.id ? "#ddd" : "#fff",
              border: "1px solid #ccc",
              cursor: "pointer",
            }}
          >
            {type.label}
          </button>
        </React.Fragment>
      ))}
    </>
  );
};

export default ViewButtons;--------------------------------------------------
Chemin: ./src/index.css
Taille: 1224 octets
Date de modification: 2025-06-23 18:28:33.347531700 +0100
Contenu:
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}

--------------------------------------------------
Chemin: ./src/main.jsx
Taille: 362 octets
Date de modification: 2025-06-23 18:28:33.347531700 +0100
Contenu:
import React from 'react';
import { createRoot } from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import App from './App';
import './index.css';
// import './temp.css';

const container = document.getElementById('root');
const root = createRoot(container);

root.render(
  <BrowserRouter>
    <App />
  </BrowserRouter>
);--------------------------------------------------
Chemin: ./src/styles/index.css
Taille: 409 octets
Date de modification: 2025-06-23 18:28:33.357531700 +0100
Contenu:
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  background-color: #f5f5f5;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}
--------------------------------------------------
Chemin: ./src/temp.css
Taille: 4269 octets
Date de modification: 2025-06-23 18:28:33.359531400 +0100
Contenu:

  
  h1 {
    text-align: center;
    margin-bottom: 20px;
  }
  /* Style pour le contenu du popup avec défilement */
  .popup-content {
    max-height: 200px; /* Hauteur maximale du popup */
    overflow-y: auto;  /* Activer le défilement vertical */
    padding-right: 10px; /* Espace pour éviter que le texte ne chevauche la barre de défilement */
  }
  
  .popup-content h3 {
    margin-top: 0; /* Supprimer la marge supérieure du titre */
  }
  
  .popup-content hr {
    margin: 10px 0; /* Espacement entre les accidents */
  }
  .map-container {
    border: 1px solid #ccc;
    border-radius: 5px;
    overflow: hidden;
    margin-bottom: 20px;
  }
  
  .loading, .error {
    text-align: center;
    padding: 50px;
    font-size: 20px;
  }
  
  .error {
    color: red;
  }
  
  .legend {
    background: white;
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 5px;
    margin-top: 20px;
  }
  
  .legend h3 {
    margin-top: 0;
    margin-bottom: 10px;
  }
  
  .legend-color {
    display: inline-block;
    width: 20px;
    height: 20px;
    margin-right: 10px;
    border-radius: 50%;
    vertical-align: middle;
  }
  
  .accident-details {
    margin-top: 20px;
    padding: 15px;
    border: 1px solid #ccc;
    border-radius: 5px;
    background-color: #f9f9f9;
  }
  
  .accident-details h2 {
    margin-top: 0;
  }
  
  .accidents-list {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 15px;
    margin-top: 15px;
  }
  
  .accident-card {
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 5px;
    background-color: white;
  }
  
  .accident-card h3 {
    margin-top: 0;
    margin-bottom: 10px;
    border-bottom: 1px solid #eee;
    padding-bottom: 5px;
  }
  
  button {
    padding: 8px 16px;
    background-color: #4682B4;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
  }
  
  button:hover {
    background-color: #3a6d8c;
  }
  
  .stats-panel {
    padding: 10px;
    background-color: #f5f5f5;
    margin-bottom: 10px;
    border-radius: 5px;
  }
  
  .map-container {
    position: relative;
    width: 100%;
    height: 600px;
  }
  
  .legend {
    padding: 10px;
    background-color: #fff;
    border: 1px solid #ccc;
    border-radius: 5px;
    margin-top: 10px;
  }
  
  .legend-color {
    display: inline-block;
    width: 20px;
    height: 20px;
    margin-right: 10px;
    vertical-align: middle;
  }
  
  /* client/src/App.css */
  .risky-routes-list {
    max-height: 200px;
    overflow-y: auto;
    margin-bottom: 20px;
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 5px;
  }
  
  .risky-routes-list ul {
    list-style-type: none;
    padding: 0;
  }
  
  .risky-routes-list li {
    padding: 5px 0;
    border-bottom: 1px solid #eee;
  }
  
  .risky-routes-list li:last-child {
    border-bottom: none;
  }
  
  /* Style pour les tooltips sur la carte */
  .leaflet-tooltip {
    background-color: rgba(255, 255, 255, 0.9);
    border: 1px solid #ccc;
    border-radius: 4px;
    padding: 4px 8px;
    font-size: 12px;
    font-weight: bold;
    color: #333;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  }
  /* client/src/App.css */
  
  /* Styles existants... */
  
  .leaflet-popup-content-wrapper {
    max-height: 300px; /* Hauteur maximale de la popup */
    overflow-y: auto; /* Active le défilement vertical si le contenu dépasse */
  }
  
  .leaflet-popup-content ul {
    list-style-type: none;
    padding: 0;
    margin: 0;
  }
  
  .leaflet-popup-content li {
    margin-bottom: 10px;
    padding-bottom: 10px;
    border-bottom: 1px solid #eee;
  }
  
  .leaflet-popup-content li:last-child {
    border-bottom: none;
  }
  
  .leaflet-popup-content p {
    margin: 2px 0;
  }
  
  /* Style spécifique pour la liste des accidents avec scrollbar */
  .accident-list {
    max-height: 200px; /* Hauteur maximale pour la liste des accidents */
    overflow-y: auto; /* Barre de défilement verticale */
    padding-right: 10px; /* Espace pour la scrollbar */
  }
  --------------------------------------------------
Chemin: ./vite.config.js
Taille: 226 octets
Date de modification: 2025-06-23 18:28:33.360534100 +0100
Contenu:
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react-swc';

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    historyApiFallback: true, 
  },
});
