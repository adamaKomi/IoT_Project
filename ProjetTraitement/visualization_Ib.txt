--------------------------------------------------
Chemin: ./package.json
Taille: 699 octets
Date de modification: 2025-06-23 18:28:33.368535400 +0100
Contenu:
{
  "name": "accident-map-ny",
  "version": "1.0.0",
  "description": "Application to map accidents with risk zones",
  "main": "src/server.js",
  "scripts": {
    "start": "node src/server.js",
    "import-data": "node src/import-data.js",
    "populate-risky-routes": "node src/populate-risky-routes.js",
    "client": "cd client && npm start",
    "dev": "concurrently \"npm start\" \"npm run client\""
  },
  "dependencies": {
    "axios": "^1.8.4",
    "concurrently": "^8.2.2",
    "cors": "^2.8.5",
    "express": "^4.21.2",
    "fuzzball": "^2.2.2",
    "mongodb": "^5.9.2",
    "react-icons": "^5.5.0"
  },
  "devDependencies": {
    "concurrently": "^8.2.2"
  }
}
--------------------------------------------------
Chemin: ./src/routes/accidentRoutes.js
Taille: 1196 octets
Date de modification: 2025-06-23 20:11:59.795785400 +0100
Contenu:
//récupérer une liste d'accidents depuis la base de données MongoDB
const express = require('express');
const { MongoClient } = require('mongodb');
const router = express.Router();

const mongoURI = 'mongodb://127.0.0.1:27017';
const dbName = 'accidentsDB';
const collectionName = 'accidents';

router.get('/api/accidents', async (req, res) => {
  const client = new MongoClient(mongoURI);

  try {
    await client.connect();
    const db = client.db(dbName);
    const collection = db.collection(collectionName);

    const limit = parseInt(req.query.limit) || 1000;
    //Exécute une requête MongoDB pour récupérer les accidents
    const accidents = await collection
      .find({}) //Recherche tous les documents dans la collection accidents
      .sort({ crash_date: -1, crash_time: -1 })
      .limit(limit)
      .toArray(); //Convertit les résultats en un tableau

    res.json(accidents);
  } catch (error) {
    console.error('Erreur lors de la récupération des données:', error);
    res.status(500).json({ error: 'Erreur lors de la récupération des données' });
  } finally {
    await client.close();
  }
});

module.exports = router;--------------------------------------------------
Chemin: ./src/routes/statsRoutes.js
Taille: 1583 octets
Date de modification: 2025-06-23 20:12:05.537855200 +0100
Contenu:
//calculer et renvoyer des statistiques globales sur les accidents
const express = require('express');
const { MongoClient } = require('mongodb');
const router = express.Router();

const mongoURI = 'mongodb://127.0.0.1:27017';
const dbName = 'accidentsDB';
const collectionName = 'accidents';

router.get('/api/statistics', async (req, res) => {
  const client = new MongoClient(mongoURI);

  try {
    await client.connect();
    const db = client.db(dbName);
    const collection = db.collection(collectionName);
    //Exécute une pipeline d'agrégation MongoDB pour calculer des statistiques globales sur les accidents
    const stats = await collection.aggregate([
      {
        //Regroupe tous les documents de la collection pour calculer des statistiques globales
        $group: {
          _id: null,
          totalAccidents: { $sum: 1 }, //nombre totale d'accidents
          totalInjured: { $sum: { $ifNull: ["$number_of_persons_injured", 0] } }, // nombre totale de blesses
          totalKilled: { $sum: { $ifNull: ["$number_of_persons_killed", 0] } } // nombre totale des tues
        }
      }
    ]).toArray();

    //Envoie les statistiques au client sous forme de réponse JSON
    res.json(stats[0] || { totalAccidents: 0, totalInjured: 0, totalKilled: 0 });
  } catch (error) {
    console.error('Erreur lors de la récupération des statistiques:', error);
    res.status(500).json({ error: 'Erreur lors de la récupération des statistiques' });
  } finally {
    await client.close();
  }
});

module.exports = router;--------------------------------------------------
Chemin: ./src/routes/zoneRoutes.js
Taille: 1597 octets
Date de modification: 2025-06-23 20:12:13.331873100 +0100
Contenu:
// src/routes/zoneRoutes.js
const express = require('express');
const router = express.Router();
const { MongoClient } = require('mongodb');
const axios = require('axios');
router.get('/api/accidents/zones', async (req, res) => {
  const client = new MongoClient('mongodb://127.0.0.1:27017');
  try {
    await client.connect();
    const db = client.db('accidentsDB');
    const riskyRoutesCollection = db.collection('risky_routes');
    //Exécute une requête pour récupérer les routes à risque
    const zones = await riskyRoutesCollection
      .find({})
      .sort({ globalRiskIndex: -1 })
      .toArray();
    console.log('Routes à risque renvoyées:', zones);
    res.json(zones);
  } catch (error) {
    console.error('Erreur lors de la récupération des routes à risque:', error);
    res.status(500).json({ error: 'Erreur lors de la récupération des routes à risque' });
  } finally {
    await client.close();
  }
});

// Route pour proxyfier les requêtes OSRM
router.get('/api/osrm/route', async (req, res) => {
  try {
    const { url } = req.query;
    if (!url) {
      return res.status(400).json({ error: 'URL manquante dans les paramètres de la requête' });
    }
    console.log('Requête OSRM via proxy:', url);
    const response = await axios.get(url);
    res.json(response.data);
  } catch (error) {
    console.error('Erreur lors de la requête OSRM via le proxy:', error.message);
    res.status(500).json({ error: 'Erreur lors de la récupération de l\'itinéraire via OSRM' });
  }
});

module.exports = router;--------------------------------------------------
Chemin: ./src/server.js
Taille: 3611 octets
Date de modification: 2025-06-23 20:13:55.794811200 +0100
Contenu:
const express = require('express');
const { MongoClient } = require('mongodb');
const axios = require('axios');
const cors = require('cors'); // ✅ Ajouté ici
const accidentRoutes = require('./routes/accidentRoutes');
const statsRoutes = require('./routes/statsRoutes');
const zoneRoutes = require('./routes/zoneRoutes');
const { fetchAllAccidentData, saveToMongoDB, preprocessData } = require('./utils/import-data');

const app = express();
const port = 3003;

// ✅ Middleware CORS propre
app.use(cors({
  origin: 'http://localhost:5173', // autorise les requêtes depuis Vite
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: true
}));

// Middleware pour parser le JSON
app.use(express.json());

// Monter les routes
app.use('/', accidentRoutes);
app.use('/', statsRoutes);
app.use('/', zoneRoutes);

// Définir l'URL de l'API des accidents
const apiURL = 'https://data.cityofnewyork.us/resource/h9gi-nx95.json';

// Fonction pour rafraîchir les données récentes
async function fetchRecentAccidentData() {
  let allData = [];
  let offset = 0;
  const limit = 10000;
  const batchSize = 50000;
  const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];

  while (offset < batchSize) {
    try {
      console.log(`Récupération du lot ${offset} à ${offset + limit}...`);
      const response = await axios.get(apiURL, {
        params: {
          $limit: limit,
          $offset: offset,
          $where: `crash_date >= '${sevenDaysAgo}'`,
          $order: 'crash_date DESC, crash_time DESC'
        }
      });

      if (response.data.length === 0) {
        console.log('Plus de données disponibles.');
        break;
      }

      allData = [...allData, ...response.data];
      console.log(`${response.data.length} accidents récupérés.`);
      offset += limit;

      await new Promise(resolve => setTimeout(resolve, 1000));
    } catch (error) {
      console.error('Erreur lors de la récupération des données:', error.message);
      break;
    }
  }

  console.log(`Total de ${allData.length} accidents récupérés.`);
  return allData;
}

async function refreshData() {
  let client;
  try {
    console.log('Rafraîchissement des données...');
    const newData = await fetchRecentAccidentData();
    const processedData = preprocessData(newData);

    client = new MongoClient('mongodb://127.0.0.1:27017');
    await client.connect();
    const db = client.db('accidentsDB');
    const collection = db.collection('accidents');

    const latestDateInDB = await collection.find().sort({ crash_date_obj: -1 }).limit(1).toArray();

    const newRecords = processedData.filter(newItem => {
      if (!latestDateInDB[0] || !latestDateInDB[0].crash_date_obj) return true;
      return newItem.crash_date_obj > latestDateInDB[0].crash_date_obj;
    });

    if (newRecords.length > 0) {
      await collection.insertMany(newRecords, { ordered: false });
      console.log(`${newRecords.length} nouvelles données insérées.`);
    } else {
      console.log('Aucune nouvelle donnée à insérer.');
    }
  } catch (error) {
    console.error('Erreur lors du rafraîchissement des données:', error);
  } finally {
    if (client) await client.close();
  }
}

// Exécuter la mise à jour toutes les 5 minutes
setInterval(refreshData, 300000);

// Démarrer le serveur
app.listen(port, () => {
  console.log(`Serveur démarré sur le port ${port}`);
});
--------------------------------------------------
Chemin: ./src/utils/dataCleaner.js
Taille: 2615 octets
Date de modification: 2025-06-23 18:28:33.381530500 +0100
Contenu:
// utils/dataCleaner.js
function cleanAccidentData(accident) {
    try {
      // Créer une copie de l'accident pour éviter de modifier l'original
      let cleanedAccident = { ...accident };
  
      // Normaliser les champs texte
      if (cleanedAccident.borough) {
        cleanedAccident.borough = cleanedAccident.borough.trim().toUpperCase();
      }
      if (cleanedAccident.on_street_name) {
        cleanedAccident.on_street_name = cleanedAccident.on_street_name.trim().toUpperCase();
      }
  
      // Valider et calculer le nombre total de personnes blessées
      cleanedAccident.number_of_persons_injured = (
        (parseInt(cleanedAccident.number_of_persons_injured) || 0) 
      );
  
      // Valider et calculer le nombre total de personnes tuées
      cleanedAccident.number_of_persons_killed = (
        (parseInt(cleanedAccident.number_of_persons_killed) || 0) 
      );
  
      // Valider et convertir latitude et longitude
      if (
        cleanedAccident.latitude &&
        cleanedAccident.longitude &&
        !isNaN(parseFloat(cleanedAccident.latitude)) &&
        !isNaN(parseFloat(cleanedAccident.longitude))
      ) {
        cleanedAccident.latitude = parseFloat(cleanedAccident.latitude);
        cleanedAccident.longitude = parseFloat(cleanedAccident.longitude);
      } else {
        cleanedAccident.latitude = null;
        cleanedAccident.longitude = null;
      }
  
      // Supprimer les champs inutiles ou redondants
      const requiredFields = [
        'collision_id', // Ajout de collision_id pour la déduplication
        'crash_date',
        'crash_time',
        'borough',
        'on_street_name',
        'number_of_persons_injured',
        'number_of_persons_killed',
        'contributing_factor_vehicle_1',
        'latitude',
        'longitude'
      ];
      Object.keys(cleanedAccident).forEach(key => {
        if (!requiredFields.includes(key) || (key !== 'borough' && key !== 'on_street_name' && !cleanedAccident[key])) {
          delete cleanedAccident[key];
        }
      });
  
      // Retourner l'accident nettoyé uniquement s'il a des coordonnées valides
      if (cleanedAccident.latitude === null || cleanedAccident.longitude === null) {
        console.warn('Accident filtered out due to invalid coordinates:', cleanedAccident);
        return null;
      }
  
      return cleanedAccident;
    } catch (error) {
      console.error('Erreur lors du nettoyage des données:', error);
      throw error;
    }
  }
  
  module.exports = { cleanAccidentData };--------------------------------------------------
Chemin: ./src/utils/import-data.js
Taille: 6546 octets
Date de modification: 2025-06-23 20:12:58.064272700 +0100
Contenu:
// src/import-data.js
const axios = require('axios');
const { MongoClient } = require('mongodb');
const { cleanAccidentData } = require('./dataCleaner');

const mongoURI = 'mongodb://127.0.0.1:27017';
const dbName = 'accidentsDB';
const collectionName = 'accidents';

const apiURL = 'https://data.cityofnewyork.us/resource/h9gi-nx95.json';
const batchSize =100000;
const chunkSize = 10000;

async function fetchAllAccidentData() {
  console.log('Démarrage de la récupération des données...');
  
  let allData = [];
  let offset = 0;
  
  while (offset < batchSize) {
    try {
      console.log(`Récupération du lot ${offset} à ${offset + chunkSize}...`);
      
      const response = await axios.get(apiURL, {
        params: {
          $limit: chunkSize,
          $offset: offset,
          $where: "crash_date >= '2022-01-01T00:00:00.000'", // Filtre depuis 2022
          $order: 'crash_date DESC, crash_time DESC'
        }
      });
      
      if (response.data.length === 0) {
        console.log('Plus de données disponibles.');
        break;
      }
      
      allData = [...allData, ...response.data];
      console.log(`${response.data.length} accidents récupérés.`);
      
      offset += chunkSize;
      
      await new Promise(resolve => setTimeout(resolve, 1000));
      
    } catch (error) {
      console.error('Erreur lors de la récupération des données:', error.message);
      if (error.response) {
        console.error('Détails de la réponse:', error.response.data);
      }
      break;
    }
  }
  
  console.log(`Total de ${allData.length} accidents récupérés.`);
  return allData;
}

async function saveToMongoDB(data) {
  const client = new MongoClient(mongoURI);
  
  try {
    await client.connect();
    console.log('Connecté à MongoDB');
    
    const db = client.db(dbName);
    const collection = db.collection(collectionName);
    
    await collection.createIndex({ crash_date: -1, crash_time: -1 });
    await collection.createIndex({ latitude: 1, longitude: 1 });
    await collection.createIndex({ collision_id: 1 }, { unique: true }); // Ajouter un index unique pour éviter les doublons
    
    const count = await collection.countDocuments();
    if (count > 0) {
      console.log(`La collection contient déjà ${count} documents. Nettoyage...`);
      await collection.deleteMany({});
    }
    
    console.log('Insertion des données dans MongoDB...');
    const result = await collection.insertMany(data, { ordered: false });
    
    console.log(`${result.insertedCount} accidents insérés avec succès.`);
    
  } catch (error) {
    console.error('Erreur lors de l\'enregistrement dans MongoDB:', error.message);
    if (error.code === 11000) {
      console.warn('Certains accidents ont été ignorés en raison de doublons (collision_id).');
    }
  } finally {
    await client.close();
    console.log('Connexion MongoDB fermée');
  }
}

function preprocessData(data) {
  // Étape 1 : Nettoyer les données avec cleanAccidentData
  let cleanedData = data.map(accident => {
    const cleanedAccident = cleanAccidentData(accident); // Appliquer la fonction de nettoyage
    if (!cleanedAccident) return null; // Si cleanAccidentData retourne null, ignorer cet accident
    return cleanedAccident;
  });

  // Étape 2 : Filtrer les accidents valides (non null)
  cleanedData = cleanedData.filter(accident => accident !== null);

  // Étape 3 : Traiter les données nettoyées (conversions supplémentaires si nécessaire)
  cleanedData = cleanedData.map(accident => {
    let processedAccident = { ...accident };

    // Valider et convertir latitude et longitude
    if (
      processedAccident.latitude &&
      processedAccident.longitude &&
      !isNaN(parseFloat(processedAccident.latitude)) &&
      !isNaN(parseFloat(processedAccident.longitude))
    ) {
      processedAccident.latitude = parseFloat(processedAccident.latitude);
      processedAccident.longitude = parseFloat(processedAccident.longitude);
    } else {
      processedAccident.latitude = null;
      processedAccident.longitude = null;
    }

    // Valider et convertir number_of_persons_injured
    if (
      processedAccident.number_of_persons_injured &&
      !isNaN(parseInt(processedAccident.number_of_persons_injured))
    ) {
      processedAccident.number_of_persons_injured = parseInt(processedAccident.number_of_persons_injured);
    } else {
      processedAccident.number_of_persons_injured = 0;
    }

    // Valider et convertir number_of_persons_killed
    if (
      processedAccident.number_of_persons_killed &&
      !isNaN(parseInt(processedAccident.number_of_persons_killed))
    ) {
      processedAccident.number_of_persons_killed = parseInt(processedAccident.number_of_persons_killed);
    } else {
      processedAccident.number_of_persons_killed = 0;
    }

    return processedAccident;
  })
  .filter(accident => {
    // Filtrer les accidents avec des coordonnées valides
    const isValid = 
      accident.latitude !== null && 
      accident.longitude !== null && 
      !isNaN(accident.latitude) && 
      !isNaN(accident.longitude);
    if (!isValid) {
      console.warn('Accident filtered out due to invalid coordinates:', accident);
    }
    return isValid;
  });

  // Étape 4 : Supprimer les doublons basés sur collision_id
  const seenCollisionIds = new Set();
  const uniqueData = cleanedData.filter(accident => {
    if (accident.collision_id) {
      if (seenCollisionIds.has(accident.collision_id)) {
        console.warn('Duplicate collision_id filtered out:', accident.collision_id);
        return false;
      }
      seenCollisionIds.add(accident.collision_id);
      return true;
    }
    return false; // Ignorer les accidents sans collision_id
  });

  console.log(`Après nettoyage et déduplication: ${uniqueData.length} accidents valides.`);
  return uniqueData;
}

async function main() {
  try {
    const rawData = await fetchAllAccidentData();
    const processedData = preprocessData(rawData);
    await saveToMongoDB(processedData);
    console.log('Processus d\'importation terminé avec succès.');
  } catch (error) {
    console.error('Erreur dans le processus principal:', error);
  }
}

module.exports = {
  fetchAllAccidentData,
  saveToMongoDB,
  preprocessData
};

if (require.main === module) {
  main();
}--------------------------------------------------
Chemin: ./src/utils/populate-risky-routes.js
Taille: 4059 octets
Date de modification: 2025-06-23 20:13:15.259139900 +0100
Contenu:
// src/populate-risky-routes.js
const { MongoClient } = require('mongodb');
const mongoURI = 'mongodb://127.0.0.1:27017';
const dbName = 'accidentsDB';
const normalizeRiskIndex = (riskIndex, minRisk, maxRisk) => {
  return ((riskIndex - minRisk) / (maxRisk - minRisk)) * 100;
};


async function populateRiskyRoutes() {
  const client = new MongoClient(mongoURI);
  try {
    await client.connect();
    const db = client.db(dbName);
    const accidentsCollection = db.collection('accidents');
    const riskyRoutesCollection = db.collection('risky_routes');

    // Vider la collection risky_routes si elle existe
    await riskyRoutesCollection.deleteMany({});

    // Calculer les statistiques par route et conserver les accidents
    const routeStats = await accidentsCollection
      .aggregate([
        {
        //filtrer les documents pour ne conserver que ceux qui répondent aux critères
          $match: {
            on_street_name: { $exists: true, $ne: null, $ne: '' }, // S'assurer que on_street_name existe et n'est pas vide
            latitude: { $exists: true, $ne: null, $type: ['double', 'decimal', 'int', 'long'] },
            longitude: { $exists: true, $ne: null, $type: ['double', 'decimal', 'int', 'long'] }
          }
        },
        {
        //regroupe les accidents par nom de rue (on_street_name) et calcule des statistiques pour chaque groupe
          $group: {
            _id: '$on_street_name', // Regrouper par nom de la route
            accidentCount: { $sum: 1 },
            totalInjured: { $sum: { $ifNull: ['$number_of_persons_injured', 0] } },
            totalKilled: { $sum: { $ifNull: ['$number_of_persons_killed', 0] } },
            coordinates: { $push: { lat: '$latitude', lng: '$longitude' } }, // Crée un tableau des coordonnées
            accidents: { // Ajouter une liste des accidents
              $push: {
                crash_date: '$crash_date',
                crash_time: '$crash_time',
                number_of_persons_injured: '$number_of_persons_injured',
                number_of_persons_killed: '$number_of_persons_killed',
                contributing_factor_vehicle_1: '$contributing_factor_vehicle_1',
                latitude: '$latitude',
                longitude: '$longitude'
              }
            }
          }
        },
        {
        //reformuler les documents pour inclure les champs souhaités
          $project: {
            route_name: '$_id',
            accidentCount: 1,
            totalInjured: 1,
            totalKilled: 1,
            globalRiskIndex: {
              $sum: [
                { $multiply: ['$accidentCount', 1] },
                { $multiply: ['$totalInjured', 2] },
                { $multiply: ['$totalKilled', 5] }
              ]
            },
            coordinates: 1,
            accidents: 1, 
            _id: 0
          }
        },
        { $sort: { globalRiskIndex: -1 } } // Trier par indice de risque décroissant
      ])
      .toArray();

      // Trouver le min et le max de globalRiskIndex
    const riskIndices = routeStats.map(route => route.globalRiskIndex);
    const minRisk = Math.min(...riskIndices);
    const maxRisk = Math.max(...riskIndices);

    const normalizedRouteStats = routeStats.map(route => ({
      ...route,
      normalizedRiskIndex: normalizeRiskIndex(route.globalRiskIndex, minRisk, maxRisk)
    }));

    // Insérer les résultats dans la collection risky_routes
    if (normalizedRouteStats.length > 0) {
      await riskyRoutesCollection.insertMany(normalizedRouteStats);
      console.log(`${normalizedRouteStats.length} routes insérées dans risky_routes.`);
    } else {
      console.log('Aucune route à insérer.');
    }
  } catch (error) {
    console.error('Erreur lors du calcul des routes à risque:', error);
  } finally {
    await client.close();
    console.log('Connexion MongoDB fermée');
  }
}

if (require.main === module) {
  populateRiskyRoutes();
}