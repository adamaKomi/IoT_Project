--------------------------------------------------
Chemin: ./package.json
Taille: 590 octets
Date de modification: 2025-04-14 13:21:51.210438900 +0100
Contenu:
{
  "name": "routing-alert-api",
  "version": "1.0.0",
  "description": "Microservice pour alerter les conducteurs des congestions et suggérer des itinéraires alternatifs",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "dependencies": {
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "mongodb": "^5.9.2",
    "mongoose": "^7.8.6",
    "socket.io": "^4.8.1"
  },
  "devDependencies": {
    "nodemon": "^2.0.22"
  }
}
--------------------------------------------------
Chemin: ./public/index.html
Taille: 4436 octets
Date de modification: 2025-04-14 13:21:51.212443600 +0100
Contenu:
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alertes de Congestion Routière</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body>
    <div class="container-fluid vh-100 d-flex flex-column p-3">
        <header class="mb-4 text-center">
            <h1><i class="fas fa-traffic-light"></i> Système d'Alertes de Trafic</h1>
            <p>Recevez des informations en temps réel sur les conditions de trafic et trouvez des itinéraires alternatifs</p>
        </header>

        <div class="row flex-grow-1 g-3">
            <!-- Carte à gauche -->
            <div class="col-md-8 h-100">
                <div class="card h-100 shadow">
                    <div class="card-body p-0">
                        <div id="traffic-map-root" class="h-100"></div>
                    </div>
                </div>
            </div>

            <!-- Contenu HTML à droite -->
            <div class="col-md-4 h-100 d-flex flex-column">
                <div class="card h-100 shadow overflow-auto">
                    <div class="card-body">
                        <div class="route-form">
                            <h2>Planifiez votre trajet</h2>
                            <form id="routeForm">
                                <div class="input-group">
                                    <label for="startPoint"><i class="fas fa-map-marker-alt"></i> Point de départ</label>
                                    <input type="text" id="startPoint" placeholder="Coordonnées de départ (ex: 33.689, -7.384)" required>
                                </div>
                                <div class="input-group">
                                    <label for="destination"><i class="fas fa-flag-checkered"></i> Destination</label>
                                    <input type="text" id="destination" placeholder="Coordonnées de destination (ex: 33.692, -7.381)" required>
                                </div>
                                <button type="submit" class="btn primary-btn">Trouver un itinéraire</button>
                            </form>
                        </div>

                        <div class="alerts-container">
                            <h2>Alertes de Congestion Actives</h2>
                            <div id="alertsList" class="alerts-list">
                                <p class="loading">Chargement des alertes...</p>
                            </div>
                        </div>

                        <div class="route-results">
                            <h2>Votre Itinéraire</h2>
                            <div class="route-tabs">
                                <button class="tab-btn active" data-tab="originalRoute">Itinéraire initial</button>
                                <button class="tab-btn" data-tab="alternativeRoute">Itinéraire alternatif</button>
                            </div>
                            <div id="originalRoute" class="route-tab-content active">
                                <div id="originalRouteDetails" class="route-details">
                                    <p class="no-route">Veuillez saisir un point de départ et une destination.</p>
                                </div>
                            </div>
                            <div id="alternativeRoute" class="route-tab-content">
                                <div id="alternativeRouteDetails" class="route-details">
                                    <p class="no-route">Des alternatives seront proposées si des congestions sont détectées.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Dépendances JavaScript -->
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script src="script.js"></script>
    <!-- Scripts React (à générer avec votre build) -->
    <script type="module" src="/dist/main.js"></script>
</body>
</html>--------------------------------------------------
Chemin: ./public/script.js
Taille: 8760 octets
Date de modification: 2025-04-14 13:21:51.213435100 +0100
Contenu:
document.addEventListener('DOMContentLoaded', function() {
    // Éléments du DOM
    const alertsList = document.getElementById('alertsList');
    const routeForm = document.getElementById('routeForm');
    const startPointInput = document.getElementById('startPoint');
    const destinationInput = document.getElementById('destination');
    const originalRouteDetails = document.getElementById('originalRouteDetails');
    const alternativeRouteDetails = document.getElementById('alternativeRouteDetails');
    const tabButtons = document.querySelectorAll('.tab-btn');

    // Exemple de coordonnées pour faciliter les tests
    startPointInput.value = "33.689, -7.384";
    destinationInput.value = "33.692, -7.381";

    // Socket.io pour les mises à jour en temps réel
    const socket = io(window.location.origin);
    
    socket.on('connect', () => {
        console.log('Connecté au serveur WebSocket');
    });
    
    socket.on('welcome', (data) => {
        console.log(data.message);
    });
    
    socket.on('congestion_update', (data) => {
        console.log('Mise à jour des alertes de congestion reçue');
        fetchAlerts(); // Actualiser les alertes
    });

    // Changer d'onglet
    tabButtons.forEach(button => {
        button.addEventListener('click', () => {
            tabButtons.forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.route-tab-content').forEach(tab => tab.classList.remove('active'));
            
            button.classList.add('active');
            const tabId = button.getAttribute('data-tab');
            document.getElementById(tabId).classList.add('active');
        });
    });

    // Récupérer les alertes de congestion
    async function fetchAlerts() {
        try {
            const response = await fetch('/api/alerts/congestion');
            const alerts = await response.json();
            
            if (alerts.length === 0) {
                alertsList.innerHTML = '<p class="no-alerts">Aucune alerte de congestion actuellement.</p>';
                return;
            }
            
            displayAlerts(alerts);
        } catch (error) {
            console.error('Erreur lors de la récupération des alertes:', error);
            alertsList.innerHTML = '<p class="error">Impossible de charger les alertes. Veuillez réessayer.</p>';
        }
    }

    // Afficher les alertes dans l'interface
    function displayAlerts(alerts) {
        alertsList.innerHTML = '';
        
        alerts.forEach(alert => {
            const alertCard = document.createElement('div');
            alertCard.className = `alert-card ${alert.congestionLevel}`;
            
            const timestamp = new Date(alert.timestamp);
            const formattedTime = timestamp.toLocaleTimeString();
            
            alertCard.innerHTML = `
                <h3>${formatLaneId(alert.lane_id)}</h3>
                <p>${alert.message}</p>
                <span class="alert-time">Détecté à ${formattedTime}</span>
            `;
            
            alertsList.appendChild(alertCard);
        });
    }

    // Formater les identifiants de voie pour les rendre plus lisibles
    function formatLaneId(laneId) {
        // Remplacer les caractères techniques par des noms plus compréhensibles
        return laneId
            .replace(/_0$/, '')  // Enlever le suffixe _0
            .replace(/^-/, '')   // Enlever le préfixe -
            .replace(/\d+#\d+/, 'Section $&'); // Ajouter "Section" pour les identifiants avec #
    }

    // Gérer la soumission du formulaire d'itinéraire
    routeForm.addEventListener('submit', async function(e) {
        e.preventDefault();
        
        const startCoords = parseCoordinates(startPointInput.value);
        const destCoords = parseCoordinates(destinationInput.value);
        
        if (!startCoords || !destCoords) {
            alert('Format de coordonnées invalide. Utilisez le format: latitude, longitude');
            return;
        }
        
        try {
            // Récupérer l'itinéraire original
            const originalRes = await fetch('/api/routing/route', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    start: startCoords,
                    end: destCoords
                })
            });
            
            const originalRoute = await originalRes.json();
            displayRoute(originalRoute, originalRouteDetails, true);
            
            // Récupérer les itinéraires alternatifs
            const altRes = await fetch('/api/routing/alternatives', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    start: startCoords,
                    end: destCoords
                })
            });
            
            const alternativeRoute = await altRes.json();
            displayRoute(alternativeRoute, alternativeRouteDetails, false);
            
        } catch (error) {
            console.error('Erreur lors de la récupération des itinéraires:', error);
            originalRouteDetails.innerHTML = `<p class="error">Erreur lors du calcul d'itinéraire: ${error.message}</p>`;
        }
    });

    // Convertir une chaîne de coordonnées en objet {lat, lng}
    function parseCoordinates(coordStr) {
        const parts = coordStr.split(',').map(part => parseFloat(part.trim()));
        if (parts.length !== 2 || isNaN(parts[0]) || isNaN(parts[1])) {
            return null;
        }
        return { lat: parts[0], lng: parts[1] };
    }

    // Afficher un itinéraire
    function displayRoute(routeData, container, isOriginal) {
        if (!routeData || !routeData.route) {
            container.innerHTML = '<p class="no-route">Itinéraire non disponible.</p>';
            return;
        }
        
        let html = '';
        
        // Afficher chaque segment de l'itinéraire
        routeData.route.segments.forEach((segment, index) => {
            const hasCongestion = segment.congestionLevel && segment.congestionLevel !== 'green';
            const statusClass = hasCongestion ? 'congestion' : 'ok';
            const statusText = hasCongestion ? 'Congestion' : 'Fluide';
            
            html += `
                <div class="route-segment">
                    <div class="segment-header">
                        <strong>Segment ${index + 1}: ${segment.name || formatLaneId(segment.lane_id)}</strong>
                        <span class="segment-status ${statusClass}">${statusText}</span>
                    </div>
                    <p>${segment.instruction || 'Suivez cette route'}</p>
                    ${hasCongestion ? `<p class="congestion-warning">Attention: ${segment.congestionMessage || 'Trafic ralenti sur ce segment'}</p>` : ''}
                </div>
            `;
        });
        
        // Ajouter le résumé de l'itinéraire
        html += `
            <div class="route-summary">
                <div class="route-summary-item">
                    <span class="route-summary-value">${routeData.route.distance.toFixed(1)} km</span>
                    <span class="route-summary-label">Distance</span>
                </div>
                <div class="route-summary-item">
                    <span class="route-summary-value">${Math.round(routeData.route.duration)} min</span>
                    <span class="route-summary-label">Durée</span>
                </div>
                <div class="route-summary-item">
                    <span class="route-summary-value">${routeData.route.congestionLevel || 'Normal'}</span>
                    <span class="route-summary-label">Niveau de trafic</span>
                </div>
            </div>
        `;
        
        container.innerHTML = html;
        
        // Si c'est un itinéraire alternatif et qu'il est meilleur, mettre en évidence
        if (!isOriginal && routeData.isBetterThanOriginal) {
            container.innerHTML = `
                <div class="better-route-notice">
                    <i class="fas fa-check-circle"></i> Cet itinéraire permet d'éviter les congestions
                </div>
            ` + container.innerHTML;
        }
    }

    // Charger les alertes immédiatement au chargement de la page
    fetchAlerts();
    
    // Actualiser les alertes toutes les 30 secondes
    setInterval(fetchAlerts, 30000);
});
--------------------------------------------------
Chemin: ./public/styles.css
Taille: 4668 octets
Date de modification: 2025-04-14 13:21:51.214436300 +0100
Contenu:
:root {
    --primary-color: #3498db;
    --secondary-color: #2c3e50;
    --success-color: #2ecc71;
    --warning-color: #f39c12;
    --danger-color: #e74c3c;
    --light-color: #ecf0f1;
    --dark-color: #34495e;
    --shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    line-height: 1.6;
    background-color: #f5f7fa;
    color: #333;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
}

header {
    text-align: center;
    padding: 30px 0;
    background-color: var(--primary-color);
    color: white;
    border-radius: 8px;
    margin-bottom: 30px;
    box-shadow: var(--shadow);
}

header h1 {
    margin-bottom: 10px;
}

header p {
    font-size: 1.1rem;
    opacity: 0.9;
}

h2 {
    margin-bottom: 20px;
    color: var(--secondary-color);
    border-bottom: 2px solid var(--primary-color);
    padding-bottom: 10px;
}

.route-form, .alerts-container, .route-results {
    background-color: white;
    border-radius: 8px;
    padding: 25px;
    margin-bottom: 30px;
    box-shadow: var(--shadow);
}

.input-group {
    margin-bottom: 20px;
}

label {
    display: block;
    margin-bottom: 8px;
    font-weight: 600;
    color: var(--dark-color);
}

input[type="text"] {
    width: 100%;
    padding: 12px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 16px;
    transition: border 0.3s ease;
}

input[type="text"]:focus {
    border-color: var(--primary-color);
    outline: none;
}

.btn {
    display: inline-block;
    background-color: var(--primary-color);
    color: white;
    border: none;
    padding: 12px 25px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 16px;
    font-weight: 600;
    transition: background-color 0.3s ease;
}

.btn:hover {
    background-color: #2980b9;
}

.primary-btn {
    background-color: var(--primary-color);
    width: 100%;
}

.alerts-list {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 20px;
}

.alert-card {
    border-radius: 8px;
    padding: 15px;
    position: relative;
    box-shadow: var(--shadow);
    transition: transform 0.3s ease;
}

.alert-card:hover {
    transform: translateY(-5px);
}

.alert-card.red {
    background-color: #ffebee;
    border-left: 5px solid var(--danger-color);
}

.alert-card.orange {
    background-color: #fff8e1;
    border-left: 5px solid var(--warning-color);
}

.alert-card.yellow {
    background-color: #fffde7;
    border-left: 5px solid #fbc02d;
}

.alert-time {
    font-size: 0.85rem;
    color: #777;
    margin-top: 10px;
    display: block;
}

.route-tabs {
    display: flex;
    margin-bottom: 20px;
    border-bottom: 1px solid #ddd;
}

.tab-btn {
    background: none;
    border: none;
    padding: 10px 20px;
    font-size: 16px;
    cursor: pointer;
    opacity: 0.6;
    position: relative;
}

.tab-btn:focus {
    outline: none;
}

.tab-btn.active {
    opacity: 1;
    font-weight: 600;
}

.tab-btn.active::after {
    content: '';
    position: absolute;
    bottom: -1px;
    left: 0;
    width: 100%;
    height: 3px;
    background-color: var(--primary-color);
}

.route-tab-content {
    display: none;
}

.route-tab-content.active {
    display: block;
}

.route-details {
    padding: 15px;
    background-color: var(--light-color);
    border-radius: 8px;
}

.route-segment {
    margin-bottom: 15px;
    padding-bottom: 15px;
    border-bottom: 1px dashed #ccc;
}

.route-segment:last-child {
    margin-bottom: 0;
    padding-bottom: 0;
    border-bottom: none;
}

.segment-header {
    display: flex;
    justify-content: space-between;
    margin-bottom: 10px;
}

.segment-status {
    display: inline-block;
    padding: 3px 10px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: 600;
}

.segment-status.ok {
    background-color: #e8f5e9;
    color: #2e7d32;
}

.segment-status.congestion {
    background-color: #fbe9e7;
    color: #d84315;
}

.route-summary {
    display: flex;
    justify-content: space-between;
    padding: 15px;
    background-color: #eee;
    border-radius: 8px;
    margin-top: 20px;
}

.route-summary-item {
    text-align: center;
}

.route-summary-value {
    font-size: 1.5rem;
    font-weight: 600;
    display: block;
}

.route-summary-label {
    font-size: 0.9rem;
    color: #666;
}
--------------------------------------------------
Chemin: ./server.js
Taille: 1807 octets
Date de modification: 2025-04-14 13:21:51.214436300 +0100
Contenu:
require("dotenv").config();
const cors = require("cors");
const http = require("http");
const socketIo = require("socket.io");

const app = require("./src/app");
const { connectDB } = require("./src/config/db/database");

const PORT = process.env.PORT || 4200;

app.use(cors());

// Ajout de logs pour le débogage
console.log("***** DÉMARRAGE DU SERVICE D'ALERTES DE CONGESTION *****");
console.log(`Configuration du port: ${PORT}`);

// Création du serveur HTTP
const server = http.createServer(app);

// Configuration du serveur WebSocket avec Socket.io
const io = socketIo(server, {
  cors: {
    origin: "*", // Permet toutes les origines en développement
    methods: ["GET", "POST"]
  }
});

// Partage l'instance io avec toute l'application
app.set("socketio", io);

// Gestion des connexions WebSocket
io.on("connection", (socket) => {
  console.log("Nouvelle connexion client:", socket.id);
  
  // Envoyer un message de bienvenue
  socket.emit("welcome", { message: "Connecté au service d'alerte de congestion" });
  
  // Gérer la déconnexion
  socket.on("disconnect", () => {
    console.log("Client déconnecté:", socket.id);
  });
});

const startServer = async() => {
  try {
    // Connexion à la base de données
    console.log("Tentative de connexion à la base de données...");
    await connectDB();
    
    // Démarrage du serveur
    server.listen(PORT, () => {
      console.log(`Serveur d'alertes de congestion en cours d'exécution sur http://127.0.0.1:${PORT}`);
      console.log("Le serveur est prêt à recevoir des requêtes");
    });
  } catch (error) {
    console.error("Erreur au démarrage du serveur:", error);
    process.exit(1);
  }
};

console.log("Lancement du serveur...");
startServer();
--------------------------------------------------
Chemin: ./src/app.js
Taille: 965 octets
Date de modification: 2025-04-14 13:21:51.216436200 +0100
Contenu:
const express = require("express");
const cors = require("cors");
const path = require("path");

const alertRoutes = require("./routes/alertRoutes");
const routingRoutes = require("./routes/routingRoutes");

const app = express();

// Activation de CORS pour toutes les requêtes
app.use(cors());

// Permet d'analyser le JSON dans les requêtes
app.use(express.json());

// Servir les fichiers statiques depuis le dossier 'public'
app.use(express.static(path.join(__dirname, "../public")));

// Routes
app.use("/api/alerts", alertRoutes);
app.use("/api/routing", routingRoutes);

// Route par défaut pour l'interface utilisateur
app.get("/", (req, res) => {
  res.sendFile(path.join(__dirname, "../public/index.html"));
});

// Middleware de gestion d'erreur
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({
    status: "error",
    message: err.message
  });
});

module.exports = app;
--------------------------------------------------
Chemin: ./src/config/db/database.js
Taille: 1033 octets
Date de modification: 2025-04-14 13:21:51.218054000 +0100
Contenu:
const { MongoClient } = require("mongodb");

// URI de connexion à MongoDB
const uri = process.env.MONGODB_URI || "mongodb://127.0.0.1:27017";
const dbName = "congestion_db"; 

let client;
let db;

// Connexion à la base de données
async function connectDB() {
  try {
    if (!client) {
      client = new MongoClient(uri);
      await client.connect();
      console.log("✅ Connecté avec succès à MongoDB");
    }
    
    db = client.db(dbName);
    
    // Vérifier si des données existent dans la collection traffic_data
    const dataCount = await db.collection("congestion_data").countDocuments();
    console.log(`Nombre d'enregistrements dans congestion_data: ${dataCount}`);
    
    return db;
  } catch (error) {
    console.error("❌ Erreur de connexion à MongoDB:", error);
    throw error;
  }
}

// Récupérer l'instance de la base de données
async function getDB() {
  if (!db) {
    await connectDB();
  }
  return db;
}

module.exports = { connectDB, getDB };
--------------------------------------------------
Chemin: ./src/controllers/alertController.js
Taille: 5530 octets
Date de modification: 2025-06-24 14:56:26.976945200 +0100
Contenu:
const { getDB } = require("../config/db/database");
const { analyzeCongestionData, classifyCongestionLevel } = require("../services/congestionAnalyzer");

// Récupérer toutes les alertes de congestion actives
async function getCongestionAlerts(req, res) {
  try {
    const db = await getDB();
    
    // Récupérer les données de congestion de la base de données depuis la collection traffic_data
    // au lieu de congestion_data pour correspondre à ce que le simulateur utilise
    const congestionData = await db.collection("congestion_data").find({}).toArray();
    
    console.log(`Données de trafic récupérées: ${congestionData.length} enregistrements`);
    
    // if (congestionData.length === 0) {
    //   console.log("Aucune donnée de trafic trouvée. Vérifiez que la simulation SUMO est en cours d'exécution.");
    //   return res.status(200).json([]);
    // }
    
    // // Analyser et classifier les données de congestion
    // const alerts = congestionData.map(data => {
    //   const level = classifyCongestionLevel(data);
    //   return {
    //     lane_id: data.lane_id,
    //     location: data.shape ? data.shape[0] : null, // Première position géographique de la voie
    //     congestionLevel: level.level,
    //     color: level.color,
    //     message: generateAlertMessage(level.level, data.lane_id),
    //     timestamp: new Date(),
    //     raw_data: {
    //       halting_number: data.halting_number,
    //       max_speed: data.max_speed,
    //       vehicleCount: data.vehicles ? data.vehicles.length : 0
    //     }
    //   };
    // }).filter(alert => alert.congestionLevel !== "green"); // Ne pas inclure les alertes de niveau vert (pas de congestion)
    
    console.log(`Alertes de congestion détectées: ${congestionData.length}`);
    
    res.status(200).json(congestionData);
  } catch (error) {
    console.error("Erreur lors de la récupération des alertes de congestion:", error);
    res.status(500).json({ error: error.message });
  }
}

// S'abonner aux alertes d'une zone géographique
async function subscribeToArea(req, res) {
  try {
    const { userId, area } = req.body;
    
    if (!userId || !area) {
      return res.status(400).json({ error: "userId et area sont requis" });
    }
    
    const db = await getDB();
    
    // Enregistrer l'abonnement dans la base de données
    await db.collection("user_subscriptions").updateOne(
      { userId },
      { $addToSet: { subscribedAreas: area } },
      { upsert: true }
    );
    
    // Si WebSockets est configuré
    if (req.app.get("socketio")) {
      // Ajouter l'utilisateur à une salle pour cette zone
      const io = req.app.get("socketio");
      const sockets = await io.fetchSockets();
      
      // Trouver le socket de l'utilisateur et le joindre à la salle correspondant à la zone
      for (const socket of sockets) {
        if (socket.handshake.query.userId === userId) {
          socket.join(`area_${area}`);
        }
      }
    }
    
    res.status(200).json({ message: "Abonnement aux alertes réussi", area });
  } catch (error) {
    console.error("Erreur lors de l'abonnement aux alertes:", error);
    res.status(500).json({ error: error.message });
  }
}

// Se désabonner des alertes
async function unsubscribeFromArea(req, res) {
  try {
    const { userId, area } = req.body;
    
    if (!userId) {
      return res.status(400).json({ error: "userId est requis" });
    }
    
    const db = await getDB();
    
    if (area) {
      // Supprimer une zone spécifique
      await db.collection("user_subscriptions").updateOne(
        { userId },
        { $pull: { subscribedAreas: area } }
      );
    } else {
      // Supprimer tous les abonnements
      await db.collection("user_subscriptions").deleteOne({ userId });
    }
    
    // Si WebSockets est configuré
    if (req.app.get("socketio")) {
      const io = req.app.get("socketio");
      const sockets = await io.fetchSockets();
      
      for (const socket of sockets) {
        if (socket.handshake.query.userId === userId) {
          if (area) {
            socket.leave(`area_${area}`);
          } else {
            // Quitter toutes les salles sauf la salle par défaut
            socket.rooms.forEach(room => {
              if (room !== socket.id) {
                socket.leave(room);
              }
            });
          }
        }
      }
    }
    
    res.status(200).json({ 
      message: area ? "Désabonnement de la zone réussi" : "Désabonnement de toutes les zones réussi" 
    });
  } catch (error) {
    console.error("Erreur lors du désabonnement des alertes:", error);
    res.status(500).json({ error: error.message });
  }
}

// Générer un message d'alerte en fonction du niveau de congestion
function generateAlertMessage(level, laneId) {
  switch (level) {
    case "red":
      return `ALERTE TRAFIC IMPORTANT: La route ${laneId} est fortement congestionnée. Évitez cette zone si possible.`;
    case "orange":
      return `ATTENTION: Trafic dense sur la route ${laneId}. Envisagez un itinéraire alternatif.`;
    case "yellow":
      return `INFORMATION: Circulation ralentie sur la route ${laneId}.`;
    default:
      return `Trafic normal sur la route ${laneId}.`;
  }
}

module.exports = {
  getCongestionAlerts,
  subscribeToArea,
  unsubscribeFromArea
};
--------------------------------------------------
Chemin: ./src/controllers/routingController.js
Taille: 6949 octets
Date de modification: 2025-04-14 13:21:51.220070000 +0100
Contenu:
const { getDB } = require("../config/db/database");
const { findAlternativeRoutes, calculateOptimalRoute } = require("../services/routingService");
const { classifyCongestionLevel } = require("../services/congestionAnalyzer");
const routingService = require("../services/routingService");

// Obtenir des itinéraires alternatifs en évitant les zones congestionnées
async function getAlternativeRoutes(req, res) {
  try {
    const { origin, destination } = req.body;
    
    if (!origin || !destination) {
      return res.status(400).json({ error: "L'origine et la destination sont requises" });
    }
    
    // Vérifier le format des coordonnées
    if (!isValidCoordinate(origin) || !isValidCoordinate(destination)) {
      return res.status(400).json({ 
        error: "Format de coordonnées invalide. Format attendu: [longitude, latitude]" 
      });
    }
    
    const db = await getDB();
    
    // Récupérer les données de congestion actuelles
    const congestionData = await db.collection("congestion_data").find({}).toArray();
    
    // Identifier les zones à éviter (niveaux rouge et orange)
    const areasToAvoid = congestionData
      .map(data => {
        const level = classifyCongestionLevel(data);
        return {
          lane_id: data.lane_id,
          shape: data.shape,
          congestionLevel: level.level
        };
      })
      .filter(area => ["red", "orange"].includes(area.congestionLevel));
    
    // Calculer les itinéraires alternatifs
    const routes = await findAlternativeRoutes(origin, destination, areasToAvoid);
    
    res.status(200).json({
      origin,
      destination,
      alternativeRoutes: routes
    });
  } catch (error) {
    console.error("Erreur lors du calcul des itinéraires alternatifs:", error);
    res.status(500).json({ error: error.message });
  }
}

// Calculer le meilleur itinéraire en fonction des conditions actuelles
async function calculateBestRoute(req, res) {
  try {
    const { origin, destination, preferences } = req.body;
    
    if (!origin || !destination) {
      return res.status(400).json({ error: "L'origine et la destination sont requises" });
    }
    
    // Vérifier le format des coordonnées
    if (!isValidCoordinate(origin) || !isValidCoordinate(destination)) {
      return res.status(400).json({ 
        error: "Format de coordonnées invalide. Format attendu: [longitude, latitude]" 
      });
    }
    
    const db = await getDB();
    
    // Récupérer les données de congestion actuelles
    const congestionData = await db.collection("congestion_data").find({}).toArray();
    
    // Classifier les données de congestion
    const classifiedData = congestionData.map(data => ({
      lane_id: data.lane_id,
      shape: data.shape,
      congestionLevel: classifyCongestionLevel(data).level
    }));
    
    // Calculer le meilleur itinéraire
    const optimalRoute = await calculateOptimalRoute(origin, destination, classifiedData, preferences);
    
    res.status(200).json({
      origin,
      destination,
      route: optimalRoute
    });
  } catch (error) {
    console.error("Erreur lors du calcul du meilleur itinéraire:", error);
    res.status(500).json({ error: error.message });
  }
}

// Calculer un itinéraire
async function calculateRoute(req, res) {
  try {
    const { start, end } = req.body;

    if (!start || !end) {
      return res.status(400).json({ 
        error: "Les coordonnées de départ et d'arrivée sont requises" 
      });
    }

    // Vérifier que les coordonnées sont valides
    if (!isValidCoordinateNew(start) || !isValidCoordinateNew(end)) {
      return res.status(400).json({ 
        error: "Format de coordonnées invalide, utilisez {lat, lng}" 
      });
    }

    // Récupérer les alertes de congestion pour les prendre en compte
    const db = await getDB();
    const congestionData = await db.collection("traffic_data").find({}).toArray();

    // Calculer l'itinéraire en tenant compte des données de congestion
    const route = await routingService.calculateRoute(start, end, congestionData);

    res.status(200).json({ route });
  } catch (error) {
    console.error("Erreur lors du calcul d'itinéraire:", error);
    res.status(500).json({ error: error.message });
  }
}

// Calculer des itinéraires alternatifs
async function calculateAlternativeRoutes(req, res) {
  try {
    const { start, end } = req.body;

    if (!start || !end) {
      return res.status(400).json({ 
        error: "Les coordonnées de départ et d'arrivée sont requises" 
      });
    }

    // Vérifier que les coordonnées sont valides
    if (!isValidCoordinateNew(start) || !isValidCoordinateNew(end)) {
      return res.status(400).json({ 
        error: "Format de coordonnées invalide, utilisez {lat, lng}" 
      });
    }

    console.log(`Calcul d'itinéraires alternatifs de [${start.lat}, ${start.lng}] à [${end.lat}, ${end.lng}]`);

    // Récupérer les alertes de congestion pour les prendre en compte
    const db = await getDB();
    const congestionData = await db.collection("traffic_data").find({}).toArray();

    // Calculer l'itinéraire original
    const originalRoute = await routingService.calculateRoute(start, end, congestionData);
    
    // Calculer un itinéraire alternatif évitant les zones de congestion
    const alternativeRoute = await routingService.calculateAlternativeRoute(start, end, congestionData);
    
    // Comparer les deux itinéraires pour déterminer lequel est le meilleur
    const isBetterThanOriginal = alternativeRoute.duration < originalRoute.duration;
    
    res.status(200).json({ 
      route: alternativeRoute,
      originalDuration: originalRoute.duration,
      isBetterThanOriginal
    });
  } catch (error) {
    console.error("Erreur lors du calcul d'itinéraires alternatifs:", error);
    res.status(500).json({ error: error.message });
  }
}

// Valider le format des coordonnées [longitude, latitude]
function isValidCoordinate(coord) {
  return Array.isArray(coord) && 
         coord.length === 2 && 
         typeof coord[0] === 'number' && 
         typeof coord[1] === 'number' &&
         coord[0] >= -180 && coord[0] <= 180 &&
         coord[1] >= -90 && coord[1] <= 90;
}

// Vérifier si une coordonnée est valide
function isValidCoordinateNew(coord) {
  return coord && 
         typeof coord === 'object' && 
         'lat' in coord && 
         'lng' in coord &&
         !isNaN(coord.lat) && 
         !isNaN(coord.lng) &&
         coord.lat >= -90 && 
         coord.lat <= 90 && 
         coord.lng >= -180 && 
         coord.lng <= 180;
}

module.exports = {
  getAlternativeRoutes,
  calculateBestRoute,
  calculateRoute,
  calculateAlternativeRoutes
};
--------------------------------------------------
Chemin: ./src/routes/alertRoutes.js
Taille: 534 octets
Date de modification: 2025-04-14 13:21:51.221062100 +0100
Contenu:
const express = require("express");
const { getCongestionAlerts, subscribeToArea, unsubscribeFromArea } = require("../controllers/alertController");

const router = express.Router();

// Route pour obtenir toutes les alertes de congestion actives
router.get("/congestion", getCongestionAlerts);

// Route pour s'abonner aux alertes d'une zone géographique
router.post("/subscribe", subscribeToArea);

// Route pour se désabonner des alertes
router.post("/unsubscribe", unsubscribeFromArea);

module.exports = router;
--------------------------------------------------
Chemin: ./src/routes/routingRoutes.js
Taille: 632 octets
Date de modification: 2025-04-14 13:21:51.222066500 +0100
Contenu:
const express = require("express");
const router = express.Router();
const routingController = require("../controllers/routingController");

// Route pour obtenir les itinéraires alternatifs (ancienne méthode)
router.post("/alternatives", routingController.getAlternativeRoutes);

// Route pour calculer le meilleur itinéraire (ancienne méthode)
router.post("/best-route", routingController.calculateBestRoute);

// Nouvelles routes plus intuitives
router.post("/route", routingController.calculateRoute);
router.post("/alternative-route", routingController.calculateAlternativeRoutes);

module.exports = router;
--------------------------------------------------
Chemin: ./src/services/alertService.js
Taille: 4903 octets
Date de modification: 2025-04-14 13:21:51.223063900 +0100
Contenu:
/**
 * Service d'alertes
 * Responsable de la gestion et de l'envoi des alertes de congestion
 */

const { getDB } = require("../config/db/database");
const { analyzeCongestionData, classifyCongestionLevel } = require("./congestionAnalyzer");

// Périodiquement rechercher les congestions et envoyer des alertes
async function monitorCongestion(io) {
  const db = await getDB();
  const congestionData = await db.collection("traffic_data").find({}).toArray();
  const alerts = analyzeCongestionData(congestionData).filter(data => data.congestionLevel !== "green");
  if (alerts.length > 0) {
    await saveAlerts(alerts);
    io.emit("congestion_alert", alerts);
  }
  return alerts;
}

// Enregistrer les alertes dans la base de données
async function saveAlerts(alerts) {
  try {
    const db = await getDB();
    
    // Ajouter un timestamp aux alertes
    const timestampedAlerts = alerts.map(alert => ({
      ...alert,
      timestamp: new Date(),
      active: true
    }));
    
    // Enregistrer les alertes dans la collection
    const result = await db.collection("congestion_alerts").insertMany(timestampedAlerts);
    console.log(`${result.insertedCount} alertes enregistrées dans la base de données`);
    
    return result;
  } catch (error) {
    console.error("Erreur lors de l'enregistrement des alertes:", error);
    throw error;
  }
}

// Envoyer les alertes aux utilisateurs concernés par WebSockets
function sendAlertsToUsers(io, alerts) {
  try {
    console.log("Envoi des alertes aux utilisateurs connectés...");
    
    // Pour chaque alerte, envoyer aux utilisateurs dans la zone correspondante
    alerts.forEach(alert => {
      // Format de l'alerte pour les utilisateurs
      const userAlert = {
        id: alert.lane_id,
        level: alert.congestionLevel,
        color: alert.color,
        message: generateAlertMessage(alert.congestionLevel, alert.lane_id),
        location: alert.details ? alert.details.location : null,
        timestamp: new Date()
      };
      
      // Envoyer l'alerte aux utilisateurs abonnés à cette zone
      io.to(`area_all`).emit('congestion_alert', userAlert);
      
      // Si nous avons des informations géographiques, cibler les utilisateurs par zone
      if (userAlert.location) {
        // Déterminer dans quelle zone géographique se trouve l'alerte
        // Cela dépendrait de comment vous avez structuré vos zones géographiques
        const geographicArea = determineGeographicArea(userAlert.location);
        if (geographicArea) {
          io.to(`area_${geographicArea}`).emit('congestion_alert', userAlert);
        }
      }
      
      // Envoyer des alertes plus graves à tous les utilisateurs
      if (alert.congestionLevel === "red") {
        io.emit('critical_congestion_alert', userAlert);
      }
    });
  } catch (error) {
    console.error("Erreur lors de l'envoi des alertes aux utilisateurs:", error);
  }
}

// Déterminer dans quelle zone géographique se trouve une localisation
function determineGeographicArea(location) {
  // Cette fonction serait implémentée pour déterminer la zone géographique
  // basée sur les coordonnées de la localisation
  // Exemple simple: diviser la carte en quadrants
  
  if (!location || !Array.isArray(location) || location.length < 2) {
    return null;
  }
  
  const [lon, lat] = location;
  
  // Exemple très simpliste de division par quadrants
  // Dans une implémentation réelle, vous utiliseriez un système plus sophistiqué
  if (lon >= 0 && lat >= 0) return "northeast";
  if (lon < 0 && lat >= 0) return "northwest";
  if (lon < 0 && lat < 0) return "southwest";
  if (lon >= 0 && lat < 0) return "southeast";
  
  return null;
}

// Générer un message d'alerte en fonction du niveau de congestion
function generateAlertMessage(level, laneId) {
  switch (level) {
    case "red":
      return `ALERTE TRAFIC IMPORTANT: La route ${laneId} est fortement congestionnée. Évitez cette zone si possible.`;
    case "orange":
      return `ATTENTION: Trafic dense sur la route ${laneId}. Envisagez un itinéraire alternatif.`;
    case "yellow":
      return `INFORMATION: Circulation ralentie sur la route ${laneId}.`;
    default:
      return `Trafic normal sur la route ${laneId}.`;
  }
}

// Récupérer les abonnements d'un utilisateur
async function getUserSubscriptions(userId) {
  try {
    const db = await getDB();
    const subscription = await db.collection("user_subscriptions").findOne({ userId });
    return subscription ? subscription.subscribedAreas : [];
  } catch (error) {
    console.error("Erreur lors de la récupération des abonnements:", error);
    return [];
  }
}

module.exports = {
  monitorCongestion,
  sendAlertsToUsers,
  getUserSubscriptions
};
--------------------------------------------------
Chemin: ./src/services/congestionAnalyzer.js
Taille: 4106 octets
Date de modification: 2025-04-14 13:21:51.224065700 +0100
Contenu:
/**
 * Service d'analyse de congestion
 * Ce service permet d'analyser les données de trafic et de déterminer le niveau de congestion
 */

// Analyser les données de congestion pour déterminer les niveaux
function analyzeCongestionData(congestionData) {
  return congestionData.map(data => {
    const level = classifyCongestionLevel(data);
    return {
      lane_id: data.lane_id,
      congestionLevel: level.level,
      color: level.color,
      details: {
        halting_number: data.halting_number,
        lane_length: data.lane_length,
        max_speed: data.max_speed,
        vehicles_count: data.vehicles ? data.vehicles.length : 0,
        average_speed: calculateAverageSpeed(data.vehicles)
      }
    };
  });
}

// Classifier le niveau de congestion en fonction des données
function classifyCongestionLevel(data) {
  console.log(`Analyse de congestion pour voie: ${data.lane_id}`);
  // Vérifier si les données sont valides et contiennent des véhicules
  if (!data || !data.vehicles) {
    console.log(`Données invalides ou pas de véhicules pour voie: ${data.lane_id}`);
    return { level: "green", color: "#4CAF50" };
  }

  // Extraire les informations pertinentes pour l'analyse
  const vehicleCount = data.vehicles.length;
  const laneLength = data.lane_length || 100; // Valeur par défaut si non disponible
  const haltingCount = data.halting_number || 0;
  const maxSpeed = data.max_speed || 50; // Valeur par défaut si non disponible

  console.log(`Analyse de voie ${data.lane_id}: ${vehicleCount} véhicules, ${haltingCount} arrêtés, longueur ${laneLength}m, vitesse max ${maxSpeed}km/h`);

  // Si pas de véhicules, pas de congestion
  if (vehicleCount === 0) {
    return { level: "green", color: "#4CAF50" };
  }

  // Calculer la densité des véhicules (nombre de véhicules par unité de longueur)
  const vehicleDensity = vehicleCount / laneLength;
  
  // Calculer la vitesse moyenne des véhicules
  const avgSpeed = calculateAverageSpeed(data.vehicles);
  
  // Rapport de la vitesse moyenne à la vitesse maximale
  const speedRatio = maxSpeed > 0 ? avgSpeed / maxSpeed : 1;
  
  // Nombre de véhicules à l'arrêt
  const haltingRatio = vehicleCount > 0 ? haltingCount / vehicleCount : 0;

  console.log(`Métriques de congestion: densité=${vehicleDensity.toFixed(4)}, vitesse moyenne=${avgSpeed.toFixed(2)}km/h, ratio vitesse=${speedRatio.toFixed(2)}, ratio arrêt=${haltingRatio.toFixed(2)}`);

  // Évaluer le niveau de congestion en combinant plusieurs facteurs
  // Logique de classification:
  // - Rouge: Trafic très dense et lent (forte congestion)
  // - Orange: Trafic dense avec ralentissement (congestion modérée)
  // - Jaune: Trafic légèrement ralenti (congestion légère)
  // - Vert: Trafic fluide (pas de congestion)
  
  if (haltingRatio > 0.5 || (speedRatio < 0.3 && vehicleDensity > 0.2)) {
    console.log(`Congestion ROUGE détectée sur voie ${data.lane_id}`);
    return { level: "red", color: "#F44336" };
  } else if (haltingRatio > 0.3 || (speedRatio < 0.5 && vehicleDensity > 0.15)) {
    console.log(`Congestion ORANGE détectée sur voie ${data.lane_id}`);
    return { level: "orange", color: "#FF9800" };
  } else if (haltingRatio > 0.1 || (speedRatio < 0.7 && vehicleDensity > 0.1)) {
    console.log(`Congestion JAUNE détectée sur voie ${data.lane_id}`);
    return { level: "yellow", color: "#FFEB3B" };
  } else {
    return { level: "green", color: "#4CAF50" };
  }
}

// Calculer la vitesse moyenne des véhicules
function calculateAverageSpeed(vehicles) {
  if (!vehicles || vehicles.length === 0) {
    return 0;
  }
  
  const totalSpeed = vehicles.reduce((sum, vehicle) => sum + (vehicle.speed || 0), 0);
  return totalSpeed / vehicles.length;
}

// Vérifier si une route a des accidents actifs
function hasActiveAccidents(data) {
  return data.accidents !== null && data.accidents !== undefined;
}

module.exports = {
  analyzeCongestionData,
  classifyCongestionLevel,
  hasActiveAccidents
};
--------------------------------------------------
Chemin: ./src/services/routingService.js
Taille: 6115 octets
Date de modification: 2025-04-14 13:21:51.225062300 +0100
Contenu:
/**
 * Service de routage
 * Ce service simule le calcul d'itinéraires alternatifs en évitant les zones congestionnées
 * Note: Cette version utilise des données simulées au lieu d'OSRM
 */

// Trouver des itinéraires alternatifs en évitant les zones congestionnées
async function findAlternativeRoutes(origin, destination, areasToAvoid) {
  try {
    // Simulation de calcul d'itinéraires alternatifs
    console.log(`Recherche d'itinéraires de [${origin}] à [${destination}] en évitant ${areasToAvoid.length} zones congestionnées`);
    
    // Simuler 3 itinéraires alternatifs
    const routes = [
      {
        id: "route_1",
        distance: 12500, // mètres
        duration: 1200,  // secondes
        congestionLevel: "green",
        avoidedCongestion: true,
        polyline: generateRandomPolyline(origin, destination),
        steps: generateRouteSteps(origin, destination, "principal")
      },
      {
        id: "route_2",
        distance: 13200,
        duration: 1350,
        congestionLevel: "green",
        avoidedCongestion: true,
        polyline: generateRandomPolyline(origin, destination),
        steps: generateRouteSteps(origin, destination, "secondaire")
      },
      {
        id: "route_3",
        distance: 14500,
        duration: 1500,
        congestionLevel: "yellow",
        avoidedCongestion: false,
        polyline: generateRandomPolyline(origin, destination),
        steps: generateRouteSteps(origin, destination, "tertiaire")
      }
    ];
    
    return routes;
  } catch (error) {
    console.error("Erreur lors de la recherche d'itinéraires alternatifs:", error);
    throw error;
  }
}

// Calculer l'itinéraire optimal en fonction des données de congestion
async function calculateOptimalRoute(origin, destination, congestionData, preferences = {}) {
  try {
    console.log(`Calcul du meilleur itinéraire de [${origin}] à [${destination}]`);
    
    // Identifier les voies à éviter complètement (congestion rouge)
    const lanestoAvoid = congestionData
      .filter(item => item.congestionLevel === "red")
      .map(item => item.lane_id);
    
    // Pénaliser les voies à congestion modérée (orange et jaune)
    const penalizedLanes = congestionData
      .filter(item => ["orange", "yellow"].includes(item.congestionLevel))
      .map(item => ({
        lane_id: item.lane_id,
        penalty: item.congestionLevel === "orange" ? 2.0 : 1.3 // Facteur multiplicateur pour le temps
      }));
    
    // Simuler le calcul du meilleur itinéraire
    
    // Calculer un itinéraire optimal simulé
    const optimalRoute = {
      id: "optimal_route",
      distance: 13800, // mètres
      duration: 1380,  // secondes
      congestionLevel: "green",
      polyline: generateRandomPolyline(origin, destination),
      steps: generateRouteSteps(origin, destination, "optimal"),
      avoidedCongestion: true,
      eta: new Date(Date.now() + 1380 * 1000).toISOString(),
      trafficConditions: {
        congestionPoints: 0,
        trafficFlow: "fluide"
      }
    };
    
    return optimalRoute;
  } catch (error) {
    console.error("Erreur lors du calcul de l'itinéraire optimal:", error);
    throw error;
  }
}

// Fonctions utilitaires pour la simulation

// Génère un polyline aléatoire entre deux points (simule un tracé de route)
function generateRandomPolyline(origin, destination) {
  // Dans une implémentation réelle, cette fonction serait remplacée par le polyline renvoyé par le service de routage
  const points = [origin];
  
  // Générer quelques points intermédiaires aléatoires
  const numPoints = 5;
  const [startLon, startLat] = origin;
  const [endLon, endLat] = destination;
  
  for (let i = 1; i <= numPoints; i++) {
    const ratio = i / (numPoints + 1);
    const lon = startLon + (endLon - startLon) * ratio + (Math.random() * 0.01 - 0.005);
    const lat = startLat + (endLat - startLat) * ratio + (Math.random() * 0.01 - 0.005);
    points.push([lon, lat]);
  }
  
  points.push(destination);
  return points;
}

// Génère des étapes pour un itinéraire (simule les instructions de navigation)
function generateRouteSteps(origin, destination, routeType) {
  // Simuler des instructions de navigation
  let steps = [];
  
  if (routeType === "principal") {
    steps = [
      { instruction: "Prendre la direction nord sur Avenue Principale", distance: 500 },
      { instruction: "Tourner à droite sur Boulevard Central", distance: 2200 },
      { instruction: "Continuer tout droit sur Voie Express", distance: 8000 },
      { instruction: "Prendre la sortie vers Rue de la Destination", distance: 1800 }
    ];
  } else if (routeType === "secondaire") {
    steps = [
      { instruction: "Prendre la direction nord-est sur Rue Secondaire", distance: 600 },
      { instruction: "Tourner à gauche sur Avenue Alternative", distance: 2500 },
      { instruction: "Au rond-point, prendre la 2ème sortie sur Route Parallèle", distance: 7500 },
      { instruction: "Tourner à droite sur Rue de la Destination", distance: 2600 }
    ];
  } else if (routeType === "tertiaire") {
    steps = [
      { instruction: "Prendre la direction est sur Chemin Rural", distance: 800 },
      { instruction: "Continuer sur Route Panoramique", distance: 4200 },
      { instruction: "Tourner à gauche sur Voie Périphérique", distance: 8000 },
      { instruction: "Tourner à droite sur Rue de la Destination", distance: 1500 }
    ];
  } else { // optimal
    steps = [
      { instruction: "Prendre la direction nord-ouest sur Avenue du Départ", distance: 700 },
      { instruction: "Tourner à droite sur Boulevard Rapide", distance: 3100 },
      { instruction: "Continuer tout droit sur Route Fluide", distance: 7200 },
      { instruction: "Tourner à gauche sur Rue de la Destination", distance: 2800 }
    ];
  }
  
  return steps;
}

module.exports = {
  findAlternativeRoutes,
  calculateOptimalRoute
};
